# TODO: remove
import imp
imp.load_module('electrum', *imp.find_module('lib'))
imp.load_module('electrum_gui', *imp.find_module('gui'))

import kivy
from kivy.config import Config
Config.set('graphics', 'width', '800')
Config.set('graphics', 'height', '600')

import os
import sys
import optparse
import platform
import time
import datetime
import re
import json
import traceback
import threading
import csv

from pprint import pprint
from decimal import Decimal

from kivy.app import App
from kivy.clock import Clock
from kivy.core.clipboard import Clipboard
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.uix.bubble import Bubble
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.uix.gridlayout import GridLayout
from kivy.uix.spinner import Spinner
from kivy.uix.treeview import TreeView, TreeViewLabel
from kivy.uix.checkbox import CheckBox
from kivy.uix.tabbedpanel import TabbedPanel, TabbedPanelItem
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.filechooser import FileChooserListView
from kivy.uix.listview import ListItemButton, ListItemLabel, CompositeListItem, \
    ListView
from kivy.adapters.dictadapter import DictAdapter
from kivy.adapters.listadapter import ListAdapter

from electrum import mnemonic, util, bitcoin
from electrum.interface import DEFAULT_PORTS, Interface
from electrum.simple_config import SimpleConfig
from electrum.wallet import Wallet, WalletSynchronizer
from electrum.util import set_verbosity, format_satoshis, print_error, print_msg
from electrum.commands import known_commands, Commands
from electrum.verifier import WalletVerifier
from electrum.bitcoin import is_valid, MIN_RELAY_TX_FEE

from combobox import ComboBox
from electrum_gui.i18n import languages
import electrum_gui.exchange_rate as exchange_rate

_ = lambda x: x

DEFAULT_PATH = '/tmp/'

DEBUG = True


class Dialog(object):
    def __init__(self, title, size_hint=(None, None), size=('400dp', '300dp'),
                 content_padding='0dp', buttons_padding='0dp', buttons_height='40dp'):

        layout_content = BoxLayout(orientation='vertical', padding=content_padding)

        layout_buttons = BoxLayout(orientation='horizontal', size_hint=(1, None),
                                   height=buttons_height, padding=buttons_padding)

        layout = BoxLayout(orientation='vertical')
        layout.add_widget(layout_content)
        layout.add_widget(layout_buttons)

        dialog = Popup(title=title,
                       content=layout,
                       size_hint=size_hint,
                       size=size,
                       auto_dismiss=False)

        self.layout_content = layout_content
        self.layout_buttons = layout_buttons
        self.dialog = dialog

    def open(self):
        self.dialog.open()

    def close(self):
        self.dialog.dismiss()

    def add_content(self, widget, index=0):
        self.layout_content.add_widget(widget, index)

    def add_button(self, widget, index=0):
        self.layout_buttons.add_widget(widget, index)


class SaveDialog(Dialog):
    def __init__(self, title, path=DEFAULT_PATH, filename='', filters=[]):
        super(SaveDialog, self).__init__(title, size_hint=(0.9, 0.9))

        def update_input(instance, path):
            if path:
                self.text_input.text = path[0].split('/')[-1]

        # ignore filters now since it doesn't flexible
        self.file_chooser = FileChooserListView(path=path)
        self.file_chooser.bind(selection=update_input)
        self.text_input = TextInput(size_hint_y=None, height='30dp', multiline=False)
        if filename:
            self.text_input.text = filename
        self.add_content(self.file_chooser)
        self.add_content(self.text_input)

        self.cancel_button = Button(text=_("Cancel"), on_press=lambda instance: self.close())
        self.save_button = Button(text=_("Save"))
        self.add_button(self.cancel_button)
        self.add_button(self.save_button)


class LoadDialog(Dialog):
    def __init__(self, title, path=DEFAULT_PATH, filename='', filters=[]):
        super(LoadDialog, self).__init__(title, size_hint=(0.9, 0.9))

        def update_input(instance, path):
            if path:
                self.text_input.text = path[0].split('/')[-1]

        # ignore filters now since it doesn't flexible
        self.file_chooser = FileChooserListView(path=path)
        self.file_chooser.bind(selection=update_input)
        self.text_input = TextInput(size_hint_y=None, height='30dp', multiline=False)
        if filename:
            self.text_input.text = filename
        self.add_content(self.file_chooser)
        self.add_content(self.text_input)

        self.cancel_button = Button(text=_("Cancel"), on_press=lambda instance: self.close())
        self.load_button = Button(text=_("Load"))
        self.add_button(self.cancel_button)
        self.add_button(self.load_button)


class StatusBar(object):
    def __init__(self, height='40dp', text_height='38dp', button_height='38dp'):
        layout_text = BoxLayout(orientation='horizontal', size_hint=(1, None), height=text_height)
        layout_buttons = BoxLayout(orientation='horizontal', size_hint=(1, None), height=button_height)

        layout = BoxLayout(orientation='horizontal', size_hint=(1, None), height=height)
        layout.add_widget(layout_text)
        layout.add_widget(layout_buttons)

        self.layout = layout
        self.layout_text = layout_text
        self.layout_buttons = layout_buttons

    def add_text(self, widget, index=0):
        self.layout_text.add_widget(widget, index)

    def add_button(self, widget, index=0):
        self.layout_buttons.add_widget(widget, index)


class GridView(object):
    """Workaround solution for grid view by using 2 list view.
    Sometimes the height of lines is shown properly."""

    def __init__(self, headers, widths=None, data=[], getter=lambda item, i: item[i], on_context_menu=None):
        if not isinstance(headers, list):
            raise Exception('Headers must be a list of texts')

        if widths is not None and not isinstance(widths, list):
            raise Exception('Widths must be None or a list of integers')

        if len(headers) != len(widths):
            raise Exception('Headers and widths must be in same length')

        if widths is not None:
            widths = ['%sdp' % i for i in widths]

        def generic_args_converter(row_index, item, is_header=True, getter=getter):
            cls_dicts = []

            for i, header in enumerate(headers):
                kwargs = {
                    'halign': 'left',
                    'size_hint_y': None,
                    'height': '30dp',
                    'text': getter(item, i),
                }

                if is_header:
                    kwargs['background_color'] = kwargs['selected_color'] = [0, 1, 1, 1]
                else:  # this is content
                    if on_context_menu is not None:
                        kwargs['on_press'] = on_context_menu

                if widths is not None:  # set width manually
                    kwargs['size_hint_x'] = None
                    kwargs['width'] = widths[i]

                cls_dicts.append({
                    'cls': ListItemButton,
                    'kwargs': kwargs,
                })

            return {
                'id': item[-1],
                'size_hint_y': None,
                'height': '30dp',
                'cls_dicts': cls_dicts,
            }

        def header_args_converter(row_index, item):
            return generic_args_converter(row_index, item)

        def content_args_converter(row_index, item):
            return generic_args_converter(row_index, item, is_header=False)

        header_adapter = ListAdapter(data=[headers],
                                   args_converter=header_args_converter,
                                   selection_mode='single',
                                   allow_empty_selection=False,
                                   cls=CompositeListItem)

        content_adapter = ListAdapter(data=data,
                                   args_converter=content_args_converter,
                                   selection_mode='single',
                                   allow_empty_selection=False,
                                   cls=CompositeListItem)

        # Layout
        header_box = BoxLayout(orientation='vertical', size_hint=(1, None), height='30dp')
        header_view = ListView(adapter=header_adapter)
        header_box.add_widget(header_view)

        content_box = BoxLayout(orientation='vertical')
        content_view = ListView(adapter=content_adapter)
        content_box.add_widget(content_view)

        layout = BoxLayout(orientation='vertical', padding=['0dp', '2dp'])
        layout.add_widget(header_box)
        layout.add_widget(content_box)

        self.content_adapter = content_adapter
        self.layout = layout


protocol_names = ['TCP', 'HTTP', 'SSL', 'HTTPS']
protocol_letters = 'thsg'
proxy_names = ['NONE', 'SOCKS4', 'SOCKS5', 'HTTP']
proxy_keys = ['none', 'socks4', 'socks5', 'http']

class NetworkDialog(object):
    def __init__(self, parent, instance):
        self.parent = parent
        self.instance = instance
        self.protocol = None

        conf = self.parent.conf
        wallet = self.parent.wallet
        interface = wallet.interface

        dialog = Dialog(title=_('Server'), size=('400dp', '400dp'))
        # d.setMinimumSize(375, 20)

        if instance is not None:
            if interface.is_connected:
                status = _("Connected to") + " %s" % (interface.host) + "\n%d " % (wallet.verifier.height) + _("blocks")
            else:
                status = _("Not connected")
            server = interface.server
        else:
            #import random
            status = _("Please choose a server.") + "\n" + _("Select 'Cancel' if you are offline.")
            server = interface.server

        dialog.add_content(Label(text=status, size_hint_y=None, height='40dp'))

        self.servers = interface.get_servers()

        ########## Server ##########
        self.server_label = Label(text=_("Server") + ":")
        self.server_host = TextInput(multiline=False)
        self.server_port = TextInput(multiline=False)
        # TODO: add icons/network.png
        self.server_protocol = ComboBox(
            key='h',
            items=zip(protocol_letters, protocol_names),
        )
        self.server_protocol.bind(key=self.on_change_protocol)

        vbox = BoxLayout(orientation='horizontal', size_hint_y=None, height='30dp')
        vbox.add_widget(self.server_label)
        vbox.add_widget(self.server_protocol)
        vbox.add_widget(self.server_host)
        vbox.add_widget(self.server_port)
        dialog.add_content(vbox)

        ########## Server list ##########
        self.servers_view = GridView(
            headers=[_('Active Servers') if interface.servers else _('Default Servers'), _('Limit')],
            widths=[300, 75],
        )
        self.servers_view.content_adapter.bind(on_selection_change=self.server_changed)

        dialog.add_content(self.servers_view.layout)

        ########################
        if server:
            host, port, protocol = server.split(':')
            self.set_protocol(protocol)
            self.change_server(host, protocol)
        else:
            self.set_protocol('s')

        ########################
        # TODO: review it
        # if not config.is_modifiable('server'):
        #    for w in [self.server_host, self.server_port, self.server_protocol, self.servers_list_widget]: w.setEnabled(False)

        ########## Proxy ##########
        # proxy setting
        self.proxy_label = Label(text=_("Proxy") + ":")
        self.proxy_host = TextInput(multiline=False)
        self.proxy_port = TextInput(multiline=False)
        self.proxy_mode = ComboBox(
            key='none',
            items=zip(proxy_keys, proxy_names),
        )
        vbox = BoxLayout(orientation='horizontal', size_hint_y=None, height='30dp')
        vbox.add_widget(self.proxy_label)
        vbox.add_widget(self.proxy_mode)
        vbox.add_widget(self.proxy_host)
        vbox.add_widget(self.proxy_port)
        dialog.add_content(vbox)

        def check_for_disable(instance, proxy_mode_key):
            if proxy_mode_key != 'none':
                self.proxy_host.readonly = False
                self.proxy_port.readonly = False
            else:
                self.proxy_host.readonly = True
                self.proxy_port.readonly = True

        check_for_disable(None, 'none')
        self.proxy_mode.bind(key=check_for_disable)

        # if not wallet.config.is_modifiable('proxy'):
        #    for w in [proxy_host, proxy_port, proxy_mode]: w.setEnabled(False)

        proxy_config = interface.proxy if interface.proxy else { "mode":"none", "host":"localhost", "port":"8080"}
        self.proxy_mode.key = proxy_config.get("mode")
        self.proxy_host.text = proxy_config.get("host")
        self.proxy_port.text = proxy_config.get("port")

        # server = unicode( server_host.text ) + ':' + unicode( server_port.text ) + ':' + (protocol_letters[server_protocol.currentIndex()])
        # if proxy_mode.currentText() != 'NONE':
        #    proxy = { u'mode':unicode(proxy_mode.currenttext).lower(), u'host':unicode(proxy_host.text), u'port':unicode(proxy_port.text) }
        # else:
        #    proxy = None

        ########################
        # Auto cycle
        layout_autocycle = BoxLayout(orientation='horizontal', size_hint_y=None, height='30dp')
        self.autocycle_cb = CheckBox(size_hint_x=None, width='20dp')
        self.autocycle_cb.active = conf.get('auto_cycle', True)
        if not conf.is_modifiable('auto_cycle'): self.autocycle_cb.active = False
        layout_autocycle.add_widget(self.autocycle_cb)
        layout_autocycle.add_widget(Label(text=_('Try random servers if disconnected')))

        def on_cancel_press(instance):
            dialog.close()

            # TODO: RuntimeError: threads can only be started once
            # interface.start(wait=False)
            # interface.send([('server.peers.subscribe', [])])

            # generate the first addresses, in case we are offline
            parent.wallet.synchronize()

            verifier = WalletVerifier(interface, conf)
            verifier.start()
            parent.wallet.set_verifier(verifier)
            synchronizer = WalletSynchronizer(parent.wallet, conf)
            synchronizer.start()

            if self.instance is None:  # in initial phase
                self.parent.change_password_dialog()

        def on_ok_press(instance):
            dialog.close()

            ################
            server = ':'.join([str(self.server_host.text),
                               str(self.server_port.text),
                               str(self.server_protocol.key)])

            if self.proxy_mode.key != 'none':
                proxy = { 'mode':str(self.proxy_mode.key),
                          'host':str(self.proxy_host.text),
                          'port':str(self.proxy_port.text) }
            else:
                proxy = None

            conf = self.parent.conf
            wallet = self.parent.wallet
            interface = wallet.interface
            conf.set_key("proxy", proxy, True)
            conf.set_key("server", server, True)
            interface.set_server(server, proxy)
            conf.set_key('auto_cycle', self.autocycle_cb.active, True)
            ################

            # TODO: RuntimeError: threads can only be started once
            # interface.start(wait=False)
            # interface.send([('server.peers.subscribe', [])])

            # generate the first addresses, in case we are offline
            if self.parent.action == 'create':
                parent.wallet.synchronize()

            verifier = WalletVerifier(interface, conf)
            verifier.start()
            wallet.set_verifier(verifier)
            synchronizer = WalletSynchronizer(wallet, conf)
            synchronizer.start()

            if self.parent.action == 'restore':
                try:
                    keep_it = self.parent.restore_wallet()
                    wallet.fill_addressbook()
                except:
                    import traceback
                    traceback.print_exc(file=sys.stdout)
                    self.parent.app.stop()

                if not keep_it: self.parent.app.stop()

            if self.instance is None:  # in initial phase
                self.parent.change_password_dialog()

        dialog.add_content(layout_autocycle)
        dialog.add_button(Button(text=_("Cancel"), on_press=on_cancel_press))
        dialog.add_button(Button(text=_("OK"), on_press=on_ok_press))
        dialog.open()

    def init_servers_list(self):
        data = []
        for _host, d in self.servers.items():
            if d.get(self.protocol):
                pruning_level = d.get('pruning', '')
                data.append((_host, pruning_level))
        self.servers_view.content_adapter.data = data

    def set_protocol(self, protocol):
        if protocol != self.protocol:
            self.protocol = protocol
            self.init_servers_list()

    def on_change_protocol(self, instance, protocol_key):
        p = protocol_key
        host = unicode(self.server_host.text)
        pp = self.servers.get(host)
        if p not in pp.keys():
            p = pp.keys()[0]
        port = pp[p]
        self.server_host.text = host
        self.server_port.text = port
        self.set_protocol(p)

    def server_changed(self, instance):
        try:
            index = instance.selection[0].index
        except (AttributeError, IndexError):
            return
        item = instance.get_data_item(index)
        self.change_server(item[0], self.protocol)

    def change_server(self, host, protocol):
        pp = self.servers.get(host, DEFAULT_PORTS)
        if protocol:
            port = pp.get(protocol)
            if not port: protocol = None

        if not protocol:
            if 's' in pp.keys():
                protocol = 's'
                port = pp.get(protocol)
            else:
                protocol = pp.keys()[0]
                port = pp.get(protocol)

        self.server_host.text = host
        self.server_port.text = port
        self.server_protocol.text = protocol_names[protocol_letters.index(protocol)]

        if not self.servers: return
        # TODO: what's this?
        # for p in protocol_letters:
        #    i = protocol_letters.index(p)
        #    j = self.server_protocol.model().index(i,0)
        #    #if p not in pp.keys(): # and self.interface.is_connected:
        #    #    self.server_protocol.model().setData(j, QVariant(0), Qt.UserRole-1)
        #    #else:
        #    #    self.server_protocol.model().setData(j, QVariant(33), Qt.UserRole-1)


class SettingsDialog(object):
    def __init__(self, parent, instance):
        self.parent = parent
        self.instance = instance

        dialog = Dialog(title=_('Electrum Settings'))

        def create_setting_widget(label, element, help, label_first=True):
            grid = GridLayout(cols=3, size_hint=(1, 0.5), row_force_default=True, row_default_height='40dp')
            label = Label(text=label, size_hint_x=None, width='200dp', halign='left', valign='middle', padding_x='-10dp')
            label.bind(size=label.setter('text_size'))
            if label_first:
                grid.add_widget(label)
                grid.add_widget(element)
            else:
                grid.add_widget(element)
                grid.add_widget(label)
            grid.add_widget(Button(text="?", size_hint_x=None, width='40dp',
                                   on_press=lambda instance: self.parent.help_box(content_text=help)))
            return grid

        def create_display_tab():
            layout = BoxLayout(orientation='vertical')

            self.st_nz_e = TextInput(text="%d" % self.parent.wallet.num_zeros, multiline=False, size_hint_x=None, width='100dp')
            layout.add_widget(create_setting_widget(
                    _('Display zeros'), self.st_nz_e,
                    _('Number of zeros displayed after the decimal point. For example, if this is set to 2, "1." will be displayed as "1.00"')))

            # TODO:
            # if not self.conf.is_modifiable('num_zeros'):
            #    for w in [nz_e, nz_label]: w.setEnabled(False)

            self.st_lang_combo = ComboBox(
                key=self.parent.conf.get("language", ''),
                items=languages.items(),
            )
            layout.add_widget(create_setting_widget(
                    _('Language'), self.st_lang_combo,
                    _('Select which language is used in the GUI (after restart).')))

            # TODO:
            # if not self.config.is_modifiable('language'):
            #    for w in [lang_combo, lang_label]: w.setEnabled(False)

            currencies = self.parent.exchanger.get_currencies()
            currencies.insert(0, "None")
            currencies = zip(currencies, currencies)

            self.st_cur_combo = ComboBox(
                key=self.parent.conf.get("currency", "None"),
                items=currencies,
            )
            layout.add_widget(create_setting_widget(
                    _('Currency'), self.st_cur_combo,
                    _('Select which currency is used for quotes.')))

            self.st_expert_cb = CheckBox()
            self.st_expert_cb.active = self.parent.expert_mode
            hh = _('In expert mode, your client will:') + '\n'  \
                + _(' - Show change addresses in the Receive tab') + '\n'  \
                + _(' - Display the balance of each address') + '\n'  \
                + _(' - Add freeze/prioritize actions to addresses.')
            layout.add_widget(create_setting_widget(
                    _('Expert mode'), self.st_expert_cb, hh, False))

            return layout

        def create_wallet_tab():
            layout = BoxLayout(orientation='vertical')

            self.st_fee_e = TextInput(text=self.parent.format_amount(self.parent.wallet.fee).strip(), multiline=False, size_hint_x=None, width='100dp')
            layout.add_widget(create_setting_widget(
                    _('Transaction fee'), self.st_fee_e,
                    _('Fee per kilobyte of transaction.') + ' ' \
                  + _('Recommended value') + ': ' + self.parent.format_amount(50000)))

            self.st_usechange_cb = CheckBox()
            self.st_usechange_cb.active = self.parent.wallet.use_change
            layout.add_widget(create_setting_widget(
                    _('Use change addresses'), self.st_usechange_cb,
                    _('Using change addresses makes it more difficult for other people to track your transactions.'),
                    False))

            self.st_gap_e = TextInput(text="%d" % self.parent.wallet.gap_limit, multiline=False, size_hint_x=None, width='100dp')

            msg = _('The gap limit is the maximal number of contiguous unused addresses in your sequence of receiving addresses.') + '\n' \
                  + _('You may increase it if you need more receiving addresses.') + '\n\n' \
                  + _('Your current gap limit is') + ': %d' % self.parent.wallet.gap_limit + '\n' \
                  + _('Given the current status of your address sequence, the minimum gap limit you can use is:') + ' ' + '%d' % self.parent.wallet.min_acceptable_gap() + '\n\n' \
                  + _('Warning') + ': ' \
                  + _('The gap limit parameter must be provided in order to recover your wallet from seed.') + ' ' \
                  + _('Do not modify it if you do not understand what you are doing, or if you expect to recover your wallet without knowing it!') + '\n\n'

            layout.add_widget(create_setting_widget(
                    _('Gap limit'), self.st_gap_e, msg))

            # TODO:
            # if not self.config.is_modifiable('gap_limit'):
            #    for w in [gap_e, gap_label]: w.setEnabled(False)

            units = ['BTC', 'mBTC']
            self.st_unit_combo = ComboBox(
                key=self.parent.base_unit(),
                items=zip(units, units),
            )

            layout.add_widget(create_setting_widget(
                    _('Base unit'), self.st_unit_combo,
                    _('Base unit of your wallet.') \
                    + '\n1BTC=1000mBTC.\n' \
                    + _(' This settings affects the fields in the Send tab')))

            return layout

        def create_import_export_tab():
            def do_callback(instance):
                if instance.id == 'export_labels':
                    title = _("Select file to save your labels")
                    path = DEFAULT_PATH
                    filename = "electrum_labels.dat"
                    filters = ["*.dat"]

                    def save(instance):
                        path = dialog.file_chooser.path
                        filename = dialog.text_input.text.strip()
                        labels = self.parent.wallet.labels
                        try:
                            with open(os.path.join(path, filename), 'w+') as stream:
                                json.dump(labels, stream)
                            self.parent.info_box(title="Labels exported", content_text=_("Your labels were exported to") + " '%s'" % str(filename))
                        except (IOError, os.error), reason:
                            self.parent.error_box(title="Unable to export labels", content_text=_("Electrum was unable to export your labels.") + "\n" + str(reason))
                        dialog.close()

                    dialog = SaveDialog(title, path=path, filename=filename, filters=filters)
                    dialog.save_button.bind(on_press=save)
                    dialog.open()

                elif instance.id == 'import_labels':
                    title = _("Open labels file")
                    path = DEFAULT_PATH
                    filename = ""
                    filters = ["*.dat"]

                    def load(instance):
                        path = dialog.file_chooser.path
                        filename = dialog.text_input.text.strip()

                        labels = self.parent.wallet.labels
                        try:
                            with open(os.path.join(path, filename), 'r') as stream:
                                for key, value in json.loads(stream.read()).items():
                                    self.parent.wallet.labels[key] = value
                                self.parent.wallet.save()
                            self.parent.info_box(title="Labels imported", content_text=_("Your labels were imported from") + " '%s'" % str(filename))
                        except (IOError, os.error), reason:
                            self.parent.error_box(title="Unable to import labels", content_text=_("Electrum was unable to import your labels.") + "\n" + str(reason))

                        dialog.close()

                    dialog = LoadDialog(title, path=path, filename=filename, filters=filters)
                    dialog.load_button.bind(on_press=load)
                    dialog.open()

                elif instance.id == 'export_history':
                    title = _("Select file to export your wallet transactions to")
                    path = os.path.expanduser('~')
                    filename = "electrum-history.csv"
                    filters = ["*.csv"]

                    def save(instance):
                        path = dialog.file_chooser.path
                        filename = dialog.text_input.text.strip()
                        # extracted from gui_lite.csv_transaction
                        wallet = self.parent.wallet
                        try:
                            with open(os.path.join(path, filename), "w+") as stream:
                                transaction = csv.writer(stream)
                                transaction.writerow(["transaction_hash", "label", "confirmations", "value", "fee", "balance", "timestamp"])
                                for item in wallet.get_tx_history():
                                    tx_hash, confirmations, is_mine, value, fee, balance, timestamp = item
                                    if confirmations:
                                        if timestamp is not None:
                                            try:
                                                time_string = datetime.datetime.fromtimestamp(timestamp).isoformat(' ')[:-3]
                                            except [RuntimeError, TypeError, NameError] as reason:
                                                time_string = "unknown"
                                                pass
                                        else:
                                          time_string = "unknown"
                                    else:
                                        time_string = "pending"

                                    if value is not None:
                                        value_string = format_satoshis(value, True, wallet.num_zeros)
                                    else:
                                        value_string = '--'

                                    if fee is not None:
                                        fee_string = format_satoshis(fee, True, wallet.num_zeros)
                                    else:
                                        fee_string = '0'

                                    if tx_hash:
                                        label, is_default_label = wallet.get_label(tx_hash)
                                    else:
                                      label = ""

                                    balance_string = format_satoshis(balance, False, wallet.num_zeros)
                                    transaction.writerow([tx_hash, label, confirmations, value_string, fee_string, balance_string, time_string])
                                self.parent.info_box(title="CSV Export created", content_text="Your CSV export has been successfully created.")
                        except (IOError, os.error), reason:
                            export_error_label = _("Electrum was unable to produce a transaction export.")
                            self.parent.error_box(title="Unable to create csv", content_text=export_error_label + "\n" + str(reason))
                        dialog.close()

                    dialog = SaveDialog(title, path=path, filename=filename, filters=filters)
                    dialog.save_button.bind(on_press=save)
                    dialog.open()

                elif instance.id == 'export_privkey':
                    # NOTE: equivalent to @protected
                    def protected_save_dialog(instance=None, password=None):
                        def show_save_dialog(instance):
                            title = _("Select file to export your private keys to")
                            path = DEFAULT_PATH
                            filename = "electrum-private-keys.csv"
                            filters = ["*.csv"]

                            def save(instance):
                                path = dialog.file_chooser.path
                                filename = dialog.text_input.text.strip()
                                try:
                                    with open(os.path.join(path, filename), "w+") as csvfile:
                                        transaction = csv.writer(csvfile)
                                        transaction.writerow(["address", "private_key"])
                                        for addr, pk in self.parent.wallet.get_private_keys(self.parent.wallet.addresses(True), password).items():
                                            transaction.writerow(["%34s" % addr, pk])
                                        self.parent.info_box(content_text=_("Private keys exported."))
                                except (IOError, os.error), reason:
                                    export_error_label = _("Electrum was unable to produce a private key-export.")
                                    return self.parent.info_box(title="Unable to create csv", content_text=export_error_label + "\n" + str(reason))
                                except BaseException, e:
                                  return self.parent.info_box(content_text=str(e))

                                dialog.close()

                            dialog = SaveDialog(title, path=path, filename=filename, filters=filters)
                            dialog.save_button.bind(on_press=save)
                            dialog.open()

                        self.parent.info_box(content_text="%s\n%s\n%s" % (
                                        _("WARNING: ALL your private keys are secret."),
                                        _("Exposing a single private key can compromise your entire wallet!"),
                                        _("In particular, DO NOT use 'redeem private key' services proposed by third parties.")),
                                      callback=show_save_dialog)

                    if self.parent.wallet.use_encryption:
                        return self.parent.password_required_dialog(post_ok=protected_save_dialog)
                    return protected_save_dialog()

                elif instance.id == 'import_privkey':
                    # NOTE: equivalent to @protected
                    def protected_load_dialog(instance=None, password=None):
                        def show_privkey_dialog(instance=None):
                            def do_cancel_privkey(instance):
                                import_dialog.close()
                                confirm_dialog.close()

                            def do_import_privkey(instance):
                                text = text_input.text.split()
                                badkeys = []
                                addrlist = []
                                for key in text:
                                    try:
                                        addr = self.parent.wallet.import_key(key, password)
                                    except BaseException as e:
                                        badkeys.append(key)
                                        continue
                                    if not addr:
                                        badkeys.append(key)
                                    else:
                                        addrlist.append(addr)
                                if addrlist:
                                    self.parent.info_box(title=_('Information'), content_text=_("The following addresses were added") + ':\n' + '\n'.join(addrlist))
                                if badkeys:
                                    self.parent.error_box(title=_('Error'), content_text=_("The following inputs could not be imported") + ':\n' + '\n'.join(badkeys))
                                self.parent.update_receive_tab()
                                self.parent.update_history_tab()

                                if instance is not None:  # called via callback
                                    confirm_dialog.close()

                            # Init another dialog
                            text_input = TextInput()
                            import_dialog = Dialog(title=_('Import private keys'))
                            import_dialog.add_content(Label(text=_("Enter private keys") + ':'))
                            import_dialog.add_content(text_input)
                            import_dialog.add_button(Button(text=_('Cancel'), on_press=do_cancel_privkey))
                            import_dialog.add_button(Button(text=_('Import'), on_press=do_import_privkey))
                            import_dialog.open()

                        if not self.parent.wallet.imported_keys:
                            confirm_dialog = Dialog(title=_('Warning'))
                            label = Label(text='[b]' + _('Warning') + ':[/b]\n' + _('Imported keys are not recoverable from seed.') + ' ' \
                                                    + _('If you ever need to restore your wallet from its seed, these keys will be lost.') + '\n\n' \
                                                    + _('Are you sure you understand what you are doing?'),
                                                    markup=True)
                            label.bind(size=label.setter('text_size'))
                            confirm_dialog.add_content(label)
                            confirm_dialog.add_button(Button(text=_("No"), on_press=lambda instance: confirm_dialog.close()))
                            confirm_dialog.add_button(Button(text=_("Yes"), on_press=show_privkey_dialog))
                            confirm_dialog.open()
                        else:
                            show_privkey_dialog()

                    if self.parent.wallet.use_encryption:
                        return self.parent.password_required_dialog(post_ok=protected_load_dialog)
                    return protected_load_dialog()

                elif instance.id == 'show_pubkey':
                    dialog = Dialog(title=_("Master Public Key"))

                    # NOTE: Kivy TextInput doesn't wrap long text. So must handle it manually
                    pub_key = self.parent.wallet.get_master_public_key()
                    pub_key = '%s\n%s\n%s\n%s' % (pub_key[0:31], pub_key[32:63], pub_key[64:95], pub_key[96:127])
                    dialog.add_content(Label(text=_('Your Master Public Key is:')))
                    dialog.add_content(TextInput(text=pub_key, readonly=True))
                    dialog.add_button(Button(text=_("OK"), on_press=lambda instance: dialog.close()))

                    dialog.open()

                elif instance.id == 'from_file':
                    title = _("Select your transaction file")
                    path = DEFAULT_PATH
                    filename = ""
                    filters = ["*.txn"]

                    def load(instance):
                        path = dialog.file_chooser.path
                        filename = dialog.text_input.text.strip()

                        if not filename:
                            return
                        try:
                            with open(os.path.join(path, filename), "r") as f:
                                file_content = f.read()
                        except (ValueError, IOError, os.error), reason:
                            self.parent.error_box(title="Unable to read file or no transaction found",
                                           content_text=_("Electrum was unable to open your transaction file") + "\n" + str(reason))

                        tx_dict = self.parent.tx_dict_from_text(file_content)
                        if tx_dict:
                            self.parent.create_process_transaction_window(tx_dict)

                        dialog.close()

                    dialog = LoadDialog(title, path=path, filename=filename, filters=filters)
                    dialog.load_button.bind(on_press=load)
                    dialog.open()

                elif instance.id == 'from_text':
                    def load_transaction(instance):
                        text = transaction_input.text
                        if not text:
                            return
                        tx_dict = self.parent.tx_dict_from_text(text)
                        if tx_dict:
                            self.parent.create_process_transaction_window(tx_dict)

                    dialog = Dialog(title=_("Input raw transaction"))

                    transaction_input = TextInput()
                    dialog.add_content(Label(text=_('Transaction:')))
                    dialog.add_content(transaction_input)
                    dialog.add_button(Button(text=_("Cancel"), on_press=lambda instance: dialog.close()))
                    dialog.add_button(Button(text=_("Load transaction"), on_press=load_transaction))

                    dialog.open()

                # End of do_callback() #

            # Layout of this tab
            layout = BoxLayout(orientation='vertical')

            buttons = BoxLayout(orientation='horizontal')
            buttons.add_widget(Button(id='export_labels', text=_('Export'), on_press=do_callback))
            buttons.add_widget(Button(id='import_labels', text=_('Import'), on_press=do_callback))
            layout.add_widget(create_setting_widget(
                    _('Labels'), buttons,
                    _('Export your labels as json')))

            buttons = BoxLayout(orientation='horizontal')
            buttons.add_widget(Button(id='export_history', text=_('Export'), on_press=do_callback))
            layout.add_widget(create_setting_widget(
                    _('History'), buttons,
                    _('Export your transaction history as csv')))

            buttons = BoxLayout(orientation='horizontal')
            buttons.add_widget(Button(id='export_privkey', text=_('Export'), on_press=do_callback))
            buttons.add_widget(Button(id='import_privkey', text=_('Import'), on_press=do_callback))
            layout.add_widget(create_setting_widget(
                    _('Private keys'), buttons,
                    _('Import private key')))

            buttons = BoxLayout(orientation='horizontal')
            buttons.add_widget(Button(id='show_pubkey', text=_('Show'), on_press=do_callback))
            layout.add_widget(create_setting_widget(
                    _('Master Public Key'), buttons,
                    _('Your Master Public Key can be used to create receiving addresses, but not to sign transactions.') + ' ' \
                      + _('If you give it to someone, they will be able to see your transactions, but not to spend your money.') + ' ' \
                      + _('If you restore your wallet from it, a watching-only (deseeded) wallet will be created.')))

            buttons = BoxLayout(orientation='horizontal')
            buttons.add_widget(Button(id='from_file', text=_('From file'), on_press=do_callback))
            buttons.add_widget(Button(id='from_text', text=_('From text'), on_press=do_callback))
            layout.add_widget(create_setting_widget(
                    _('Load transaction'), buttons,
                    _("This will give you the option to sign or broadcast a transaction based on it's status.")))

            return layout

        # Add setting tabs
        tabs = TabbedPanel(do_default_tab=False)
        self.add_tab(tabs, create_display_tab(), _('Display'))
        self.add_tab(tabs, create_wallet_tab(), _('Wallet'))
        self.add_tab(tabs, create_import_export_tab(), _('Import/Export'))
        # no plugins for Kivy GUI

        dialog.add_content(tabs)

        self.parent.run_hook('create_settings_tab')  # removed 2nd arg

        def on_ok_press(instance):
            dialog.close()

            ##########
            fee = unicode(self.st_fee_e.text)
            try:
                fee = self.parent.read_amount(fee)
            except:
                return self.parent.error_box(content_text=_('Invalid value') + ': %s' % fee)

            self.parent.wallet.set_fee(fee)

            ##########
            nz = unicode(self.st_nz_e.text)
            try:
                nz = int(nz)
                if nz > 8: nz = 8
            except:
                return self.parent.error_box(content_text=_('Invalid value') + ':%s' % nz)

            if self.parent.wallet.num_zeros != nz:
                self.parent.wallet.num_zeros = nz
                self.parent.conf.set_key('num_zeros', nz, True)
                self.parent.update_history_tab()
                self.parent.update_receive_tab()

            usechange_result = self.st_usechange_cb.active
            if self.parent.wallet.use_change != usechange_result:
                self.parent.wallet.use_change = usechange_result
                self.parent.conf.set_key('use_change', self.parent.wallet.use_change, True)

            unit_result = self.st_unit_combo.text
            if self.parent.base_unit() != unit_result:
                self.parent.decimal_point = 8 if unit_result == 'BTC' else 5
                self.parent.conf.set_key('decimal_point', self.parent.decimal_point, True)
                self.parent.update_history_tab()
                self.parent.update_status()

            try:
                n = int(self.st_gap_e.text)
            except:
                return self.parent.error_box(content_text=_('Invalid value'))

            if self.parent.wallet.gap_limit != n:
                if self.parent.wallet.change_gap_limit(n):
                    self.parent.update_receive_tab()
                    self.parent.conf.set_key('gap_limit', self.parent.wallet.gap_limit, True)
                else:
                    self.parent.error_box(content_text=_('Invalid value'))
                    # TODO: no return???

            need_restart = False

            lang_request = str(self.st_lang_combo.key)
            if lang_request != self.parent.conf.get('language'):
                self.parent.conf.set_key("language", lang_request, True)  # TODO: why can't save unicode
                need_restart = True

            cur_request = str(self.st_cur_combo.text)
            if cur_request != self.parent.conf.get('currency', "None"):
                self.parent.conf.set_key('currency', cur_request, True)  # TODO: why can't save unicode
                self.parent.update_wallet()

            self.parent.run_hook('close_settings_dialog')

            if need_restart:
                self.parent.info_box(content_text=_('Please restart Electrum to activate the new GUI settings'))

            # from receive_tab_set_mode()
            self.parent.save_column_widths()
            self.parent.expert_mode = self.st_expert_cb.active
            self.parent.conf.set_key('classic_expert_mode', self.parent.expert_mode, True)
            self.parent.update_receive_tab()

        dialog.add_button(Button(text=_("Cancel"), on_press=lambda instance: dialog.close()))
        dialog.add_button(Button(text=_("OK"), on_press=on_ok_press))
        dialog.open()

    def add_tab(self, tabs, widget, title):
        tab = TabbedPanelItem(text=title)
        tab.add_widget(widget)
        tabs.add_widget(tab)


class ElectrumGui(object):
    def __init__(self, app):
        self.app = app
        self.wallet = app.wallet
        self.conf = app.conf
        self.action = None  # updated by self.restore_or_create_dialog()

    def _message_box(self, title, content_text, button_text=_("OK"), callback=None):
        def _callback(instance):
            dialog.close()
            if callback is not None and callable(callback):
                apply(callback, [instance])

        dialog = Dialog(title, size=('400dp', '200dp'))
        label = Label(text=content_text)
        label.bind(size=label.setter('text_size'))
        dialog.add_content(label)
        dialog.add_button(Button(text=button_text, on_press=_callback))
        dialog.open()

        return dialog

    def info_box(self, title=_("Info"), content_text=_("More info"), button_text=_("OK"), callback=None):
        return self._message_box(title, content_text, button_text, callback=callback)

    def help_box(self, title=_("Help"), content_text=_("More help"), button_text=_("OK"), callback=None):
        return self._message_box(title, content_text, button_text, callback=callback)

    def error_box(self, title=_("Error"), content_text=_("Error info"), button_text=_("OK"), callback=None):
        return self._message_box(title, content_text, button_text, callback=callback)

    def exit_box(self, title=_("Error"), content_text=_("Error info"), button_text=_("OK")):
        return self._message_box(title, content_text, button_text, callback=lambda instance: self.app.stop())

    def init_seed_dialog(self, instance=None, password=None):  # renamed from show_seed()
        """Can be called directly (password is None)
        or from a password-protected callback (password is not None)"""

        if not self.wallet.seed:
            return self.error_box(content_text=_('No seed'))

        if password is None:
            seed = self.wallet.seed
        else:
            try:
                seed = self.wallet.decode_seed(password)
            except:
                return self.error_box(content_text=_('Incorrect Password'))

        dialog = Dialog(title='Electrum' + ' - ' + _('Seed'), size=('400dp', '400dp'))

        brainwallet = ' '.join(mnemonic.mn_encode(seed))

        label1 = Label(text=_("Your wallet generation seed is") + ":")
        label1.bind(size=label1.setter('text_size'))

        if DEBUG:
            seed_text = TextInput(text=brainwallet, size_hint=(1, 2), multiline=True, readonly=False)  # allow copy-paste
        else:
            seed_text = TextInput(text=brainwallet, size_hint=(1, 2), multiline=True, readonly=True)

        # seed_text.setMaximumHeight(130)

        msg2 = _("Please write down or memorize these 12 words (order is important).") + " " \
              + _("This seed will allow you to recover your wallet in case of computer failure.") + " " \
              + _("Your seed is also displayed as QR code, in case you want to transfer it to a mobile phone.") + "\n" \
              + "[b]" + _("WARNING") + ":[/b] " + _("Never disclose your seed. Never type it on a website.")
        if self.wallet.imported_keys:
            msg2 += "[b]" + _("WARNING") + ":[/b] " + _("Your wallet contains imported keys. These keys cannot be recovered from seed.")
        label2 = Label(text=msg2, size_hint=(1, 4), valign='top', markup=True)
        label2.bind(size=label2.setter('text_size'))

        # TODO: add this
#         logo = QLabel()
#         logo.setPixmap(QPixmap(":icons/seed.png").scaledToWidth(56))
#         logo.setMaximumWidth(60)
#
#         qrw = QRCodeWidget(seed)
#
#         ok_button = QPushButton(_("OK"))
#         ok_button.setDefault(True)
#         ok_button.clicked.connect(dialog.accept)
#
#         grid = QGridLayout()
#         #main_layout.addWidget(logo, 0, 0)
#
#         grid.addWidget(logo, 0, 0)
#         grid.addWidget(label1, 0, 1)
#
#         grid.addWidget(seed_text, 1, 0, 1, 2)
#
#         grid.addWidget(qrw, 0, 2, 2, 1)
#
#         vbox = QVBoxLayout()
#         vbox.addLayout(grid)
#         vbox.addWidget(label2)

        def on_ok_press(_instance):
            dialog.close()
            if instance is None:  # in initial phase
                self.verify_seed_dialog()

        dialog.add_content(label1)
        dialog.add_content(seed_text)
        dialog.add_content(label2)
        dialog.add_button(Button(text=_("OK"), on_press=on_ok_press))
        dialog.open()

    def change_network_dialog(self, instance=None):  # renamed from network_dialog()
        """Can be called directly (instance is None)
        or from a callback (instance is not None)"""
        NetworkDialog(self, instance)

    def change_password_dialog(self, instance=None):
        """Can be called directly (instance is None)
        or from a callback (instance is not None)"""

        wallet = self.wallet

        if not wallet.seed:
            return self.exit_box(content_text=_('No seed'))

        dialog = Dialog(title=_('Password'))

        pw = TextInput(password=True)
        new_pw = TextInput(password=True)
        conf_pw = TextInput(password=True)

        if instance is not None:
            msg = (_('Your wallet is encrypted. Use this dialog to change your password.') + '\n'\
                   + _('To disable wallet encryption, enter an empty new password.')) \
                   if wallet.use_encryption else _('Your wallet keys are not encrypted')
        else:
            msg = _("Please choose a password to encrypt your wallet keys.") + '\n'\
                  + _("Leave these fields empty if you want to disable encryption.")
        dialog.add_content(Label(text=msg))

        grid = GridLayout(cols=2)
        # grid.setSpacing(8)

        if wallet.use_encryption:
            grid.add_widget(Label(text=_('Password')))
            grid.add_widget(pw)

        grid.add_widget(Label(text=_('New Password')))
        grid.add_widget(new_pw)

        grid.add_widget(Label(text=_('Confirm Password')))
        grid.add_widget(conf_pw)

        dialog.add_content(grid)

        def on_ok_press(_instance):
            password = unicode(pw.text) if wallet.use_encryption else None
            new_password = unicode(new_pw.text)
            new_password2 = unicode(conf_pw.text)

            try:
                seed = wallet.decode_seed(password)
            except:
                return self.error_box(content_text=_('Incorrect Password'))

            if new_password != new_password2:
                return self.error_box(content_text=_('Passwords do not match'))

            # TODO: test carefully
            try:
                wallet.update_password(seed, password, new_password)
            except:
                return self.exit_box(content_text=_('Failed to update password'))
            else:
                self.info_box(title=_('Success'), content_text=_('Password was updated successfully'))

            # TODO: review
            # if instance:
            #    icon = QIcon(":icons/lock.png") if wallet.use_encryption else QIcon(":icons/unlock.png")
            #    instance.password_button.setIcon( icon )

            dialog.close()
            if instance is None:  # in initial phase
                self.load_wallet()

        dialog.add_button(Button(text=_("Cancel"), on_press=lambda _instance: dialog.close()))
        dialog.add_button(Button(text=_("OK"), on_press=on_ok_press))
        dialog.open()


class ElectrumInitGui(ElectrumGui):
    def __init__(self, app):
        super(ElectrumInitGui, self).__init__(app)

    def restore_or_create_dialog(self):
        def on_create_press(instance):
            dialog.close()
            self.action = 'create'
            self.wallet.init_seed(None)
            self.init_seed_dialog()

        def on_restore_press(instance):
            dialog.close()
            self.action = 'restore'
            self.verify_seed_dialog(is_restore=True)

        msg = _("Wallet file not found.") + "\n" + _("Do you want to create a new wallet, or to restore an existing one?")
        label = Label(text=msg, valign='middle')
        label.bind(size=label.setter('text_size'))

        dialog = Dialog(title=_('Message'))
        dialog.add_content(label)
        dialog.add_button(Button(text=_('Create'), on_press=on_create_press))
        dialog.add_button(Button(text=_('Restore'), on_press=on_restore_press))
        dialog.add_button(Button(text=_('Cancel'), on_press=lambda instance: self.app.stop()))
        dialog.open()

    def verify_seed_dialog(self, is_restore=False):
        dialog = Dialog(title=_("Seed confirmation"))

        vbox = BoxLayout(orientation='vertical')
        if is_restore:
            msg = _("Please enter your wallet seed (or your master public key if you want to create a watching-only wallet)." + ' ')
        else:
            msg = _("Your seed is important! To make sure that you have properly saved your seed, please type it here." + ' ')

        msg += _("Your seed can be entered as a sequence of words, or as a hexadecimal string." + '\n')

        label = Label(text=msg)
        label.bind(size=label.setter('text_size'))
        vbox.add_widget(label)

        seed_e = TextInput()
        if DEBUG: seed_e = TextInput(text=self.wallet.seed)  # prefill
        # seed_e.setMaximumHeight(100)
        vbox.add_widget(seed_e)

        if is_restore:
            grid = GridLayout(cols=3, size_hint=(1, 0.5), row_force_default=True, row_default_height='40dp')
            # grid.setSpacing(8)

            msg = _('Keep the default value unless you modified this parameter in your wallet.')
            gap_e = TextInput(text="5", multiline=False)
            grid.add_widget(Label(text=_('Gap limit'), size_hint_x=None, width='80dp'))
            grid.add_widget(gap_e)
            grid.add_widget(Button(text="?", size_hint_x=None, width='40dp',
                                   on_press=lambda instance: self.help_box(content_text=msg)))
            vbox.add_widget(grid)

        def on_ok_press(instance):
            dialog.close()

            seed = seed_e.text

            try:
                seed.decode('hex')
            except:
                try:
                    seed = mnemonic.mn_decode(seed.split())
                except:
                    return self.exit_box(content_text=_('I cannot decode this'))

            if not seed:
                return self.exit_box(content_text=_('No seed'))

            wallet = self.wallet
            if not is_restore:  # Create
                if seed != wallet.seed:
                    return self.exit_box(content_text=_('Incorrect seed'))
                wallet.save_seed()
            else:  # Restore
                try:
                    gap = int(unicode(gap_e.text))
                except:
                    return self.exit_box(content_text=_('Gap must be an integer'))
                wallet.gap_limit = gap
                if len(seed) == 128:
                    wallet.seed = ''
                    wallet.init_sequence(str(seed))
                else:
                    wallet.init_seed(str(seed))
                    wallet.save_seed()

            return self.change_network_dialog()

        dialog.add_content(vbox)
        dialog.add_button(Button(text=_("Cancel"), on_press=lambda instance: self.app.stop()))
        dialog.add_button(Button(text=_("OK"), on_press=on_ok_press))
        dialog.open()

    def restore_wallet(self):
        return True  # TODO

        wallet = self.wallet
        # wait until we are connected, because the user might have selected another server
        if not wallet.interface.is_connected:
            waiting = lambda: False if wallet.interface.is_connected else "%s \n" % (_("Connecting..."))
            waiting_dialog(waiting)

        waiting = lambda: False if wallet.is_up_to_date() else "%s\n%s %d\n%s %.1f"\
            % (_("Please wait..."), _("Addresses generated:"), len(wallet.addresses(True)), _("Kilobytes received:"), wallet.interface.bytes_received / 1024.)

        wallet.set_up_to_date(False)
        wallet.interface.poke('synchronizer')
        waiting_dialog(waiting)
        if wallet.is_found():
            print_error("Recovery successful")
        else:
            QMessageBox.information(None, _('Error'), _("No transactions found for this seed"), _('OK'))

        return True

    def load_wallet(self):
        interface = self.wallet.interface

        interface.start(wait=False)
        interface.send([('server.peers.subscribe', [])])

        verifier = WalletVerifier(interface, self.conf)
        verifier.start()
        self.wallet.set_verifier(verifier)
        synchronizer = WalletSynchronizer(self.wallet, self.conf)
        synchronizer.start()

        url = None  # TODO:
        self.main(url)

    def main(self, url):  # TODO:
        main_gui = ElectrumMainGui(self.app)
        main_gui.show()
        main_gui.connect_slots()
        main_gui.update_wallet()


class ElectrumMainGui(ElectrumGui):
    def __init__(self, app):
        super(ElectrumMainGui, self).__init__(app)

        self.layout = BoxLayout(orientation='vertical')
        self.app.root.add_widget(self.layout)

        self.current_account = app.conf.get("current_account", None)

        self.init_plugins()
        self.create_status_bar()

        self.need_update = threading.Event()
        self.wallet.interface.register_callback('updated', lambda: self.need_update.set())
        self.wallet.interface.register_callback('banner', lambda: lambda: self.console.showMessage(self.wallet.interface.banner))
        self.wallet.interface.register_callback('disconnected', self.update_status)
        self.wallet.interface.register_callback('disconnecting', self.update_status)

        self.expert_mode = app.conf.get('classic_expert_mode', False)
        self.decimal_point = app.conf.get('decimal_point', 8)

        #### set_language(self.conf.get('language'))

        self.funds_error = False
        self.completions = []

        #### self.column_widths = self.conf.get("column_widths", default_column_widths)  # NOTE: not used in Kivy now

        self.exchanger = exchange_rate.Exchanger(self)
        #### self.connect(self, SIGNAL("refresh_balance()"), self.update_wallet)

        # set initial message
        #### self.console.showMessage(self.wallet.interface.banner)

        # fix fee
        if self.wallet.fee < 50000:
            self.wallet.set_fee(50000)
            self.info_box(content_text="Note: Your default fee was raised to 0.0005 BTC/kilobyte")

        # plugins that need to change the GUI do it here
        self.run_hook('init_gui')

    def init_plugins(self):
        # NOTE: Kivy GUI doesn't has any plugin now
        pass

    def run_hook(self, name, *args):
        # NOTE: It just depends on plugins which not exist in Kivy GUI now
        return

    def set_label(self, name, text=None):
        """Update labels in list"""
        changed = False
        old_text = self.wallet.labels.get(name)
        if text:
            if old_text != text:
                self.wallet.labels[name] = text
                changed = True
        else:
            if old_text:
                self.wallet.labels.pop(name)
                changed = True
        self.run_hook('set_label', name, text, changed)
        return changed

    def getOpenFileName(self, title, filter=None):
        # TODO:
        pass

    def getSaveFileName(self, title, filename, filter=None):
        # TODO:
        pass

    def close(self):
        self.app.stop()
        self.run_hook('close_main_window')

    def connect_slots(self):
        Clock.schedule_interval(self.timer_actions, 0.5)
        # self.previous_payto_e = ''  # For plugins only

    def timer_actions(self, interval):
        # print 'timer_actions', datetime.datetime.now()
        if self.need_update.is_set():
            self.update_wallet()
            self.need_update.clear()
        self.run_hook('timer_actions')

    def format_amount(self, x, is_diff=False):
        return format_satoshis(x, is_diff, self.wallet.num_zeros, self.decimal_point)

    def read_amount(self, x):
        if x in['.', '']: return None
        p = pow(10, self.decimal_point)
        return int(p * Decimal(x))

    def base_unit(self):
        assert self.decimal_point in [5, 8]
        return "BTC" if self.decimal_point == 8 else "mBTC"

    def update_status(self):
        if self.wallet.interface and self.wallet.interface.is_connected:
            if not self.wallet.up_to_date:
                text = _("Synchronizing...")
                # icon = QIcon(":icons/status_waiting.png")
            else:
                c, u = self.wallet.get_account_balance(self.current_account)
                text = _("Balance") + ": %s " % (self.format_amount(c)) + self.base_unit()
                if u: text += " [%s unconfirmed]" % (self.format_amount(u, True).strip())
                text += self.create_quote_text(Decimal(c + u) / 100000000)
                # icon = QIcon(":icons/status_connected.png")
        else:
            text = _("Not connected")
            # icon = QIcon(":icons/status_disconnected.png")

        self.status_text.text = text
        # self.status_button.setIcon(icon)

    def update_wallet(self):
        self.update_status()
        if self.wallet.up_to_date or not self.wallet.interface.is_connected:
            self.update_history_tab()
            self.update_receive_tab()
            self.update_contacts_tab()
            self.update_completions()

    def create_quote_text(self, btc_balance):
        quote_currency = self.conf.get("currency", "None")
        quote_balance = self.exchanger.exchange(btc_balance, quote_currency)
        if quote_balance is None:
            quote_text = ""
        else:
            quote_text = "  (%.2f %s)" % (quote_balance, quote_currency)
        return quote_text

    def create_history_tab(self):
        self.last_instance = None

        def on_context_menu(instance):
            def show_tx_details(_instance):
                tx_hash = instance.parent.id
                tx = self.wallet.transactions.get(tx_hash)

                if tx_hash in self.wallet.transactions.keys():
                    is_relevant, is_mine, v, fee = self.wallet.get_tx_value(tx)
                    conf, timestamp = self.wallet.verifier.get_confirmations(tx_hash)
                    if timestamp:
                        time_str = datetime.datetime.fromtimestamp(timestamp).isoformat(' ')[:-3]
                    else:
                        time_str = 'pending'
                else:
                    is_mine = False

                dialog = Dialog(title=_('Transaction Details'), size=('600dp', '450dp'))
                dialog.add_content(Label(text=_('Transaction ID') + ':', size_hint_y=None, height='30dp'))
                dialog.add_content(TextInput(text=tx_hash, size_hint_y=None, height='30dp', readonly=True))

                dialog.add_content(Label(text="Date: %s"%time_str, size_hint_y=None, height='30dp'))
                dialog.add_content(Label(text="Status: %d confirmations"%conf, size_hint_y=None, height='30dp'))

                if is_mine:
                    if fee is not None: 
                        dialog.add_content(Label(text="Amount sent: %s"% self.format_amount(v-fee), size_hint_y=None, height='30dp'))
                        dialog.add_content(Label(text="Transaction fee: %s"% self.format_amount(fee), size_hint_y=None, height='30dp'))
                    else:
                        dialog.add_content(Label(text="Amount sent: %s"% self.format_amount(v), size_hint_y=None, height='30dp'))
                        dialog.add_content(Label(text="Transaction fee: unknown"))
                else:
                    dialog.add_content(Label(text="Amount received: %s"% self.format_amount(v), size_hint_y=None, height='30dp'))

                dialog.add_content(self.generate_transaction_information_widget(tx))
                dialog.add_button(Button(text=_("Cancel"), on_press=lambda instance: dialog.close()))

                dialog.open()

                if self.last_instance is not None:
                    self.last_instance.clear_widgets()

            def tx_label_clicked(_instance):
                def save_description(__instance):
                    if text_input.text:
                        instance.parent.children[2].text = text_input.text
                    dialog.close()

                text = instance.parent.children[2].text
                text_input = TextInput(text=text, size_hint_y=None, height='30dp', multiline=False, focus=True)
                text_input.select_all()
                dialog = Dialog(title=_('Edit description'), size=('600dp', '130dp'))
                dialog.add_content(text_input)
                dialog.add_button(Button(text=_("Cancel"), on_press=lambda instance: dialog.close()))
                dialog.add_button(Button(text=_('OK'), on_press=save_description))
                dialog.open()

                if self.last_instance is not None:
                    self.last_instance.clear_widgets()

            if self.last_instance is not None:
                self.last_instance.clear_widgets()
            self.last_instance = instance

            context_menu = Bubble(orientation='vertical', size_hint=(None, None),
                                  size=('160dp', '80dp'), arrow_pos='bottom_mid')
            context_menu.pos = instance.pos  # TODO: more cases
            context_menu.add_widget(Button(text=_('Details'), on_press=show_tx_details))
            context_menu.add_widget(Button(text=_('Edit description'), on_press=tx_label_clicked))

            instance.add_widget(context_menu)

        self.history_view = GridView(
            headers=["", _("Date"), _("Description"), _("Amount"), _("Balance")],
            widths=[50, 150, 400, 100, 100],
            on_context_menu=on_context_menu,
        )
        self.update_history_tab()

        return self.history_view.layout

    def create_history_menu(self, position):
        # NOTE: no context menu for Kivy now
        pass

    def show_tx_details(self, tx):
        # NOTE: depend on self.create_history_menu()
        pass

    def tx_label_clicked(self, item, column):
        # TODO: depend on self.create_history_tab() and self.create_history_menu()
        pass

    def tx_label_changed(self, item, column):
        # NOTE: depend on self.create_history_menu()
        pass

    def edit_label(self, is_recv):
        # TODO:
        pass

    def address_label_clicked(self, item, column, l, column_addr, column_label):
        # TODO:
        pass

    def address_label_changed(self, item, column, l, column_addr, column_label):
        # TODO:
        pass

    def generate_transaction_information_widget(self, tx):
        def add_outputs():
            return GridView(
                headers=[_('Address'), _('Amount')],
                widths=[400, 176],
                data=[(address, self.format_amount(value)) for address, value in tx.outputs],
            ).layout

        def add_inputs():
            return GridView(
                headers=[_('Address'), _('Previous output')],
                widths=[200, 376],
                data=[(str(input["address"]), str(input["prevout_hash"])) for input in tx.inputs],
            ).layout

        tabs = TabbedPanel(do_default_tab=False)
        self.add_tab(tabs, add_outputs(), _('Outputs'))
        self.add_tab(tabs, add_inputs(), _('Inputs'))
 
        return tabs

    def current_item_changed(self, item):
        self.run_hook('current_item_changed', item)

    def update_history_tab(self):
        def parse_histories(items):
            results = []
            for item in items:
                tx_hash, conf, is_mine, value, fee, balance, timestamp = item
                if conf > 0:
                    try:
                        time_str = datetime.datetime.fromtimestamp(timestamp).isoformat(' ')[:-3]
                    except:
                        time_str = "unknown"
    
                if conf == -1:
                    time_str = 'unverified'
                    # icon = QIcon(":icons/unconfirmed.png")
                elif conf == 0:
                    time_str = 'pending'
                    # icon = QIcon(":icons/unconfirmed.png")
                elif conf < 6:
                    time_str = ''  # add new to fix error when conf < 0
                    # icon = QIcon(":icons/clock%d.png"%conf)
                    pass
                else:
                    # icon = QIcon(":icons/confirmed.png")
                    pass
    
                if value is not None:
                    v_str = self.format_amount(value, True)
                else:
                    v_str = '--'
    
                balance_str = self.format_amount(balance)
    
                if tx_hash:
                    label, is_default_label = self.wallet.get_label(tx_hash)
                else:
                    label = _('Pruned transaction outputs')
                    is_default_label = False
    
                # NOTE: just show 5 on a row but get 6. The last one is ID of that row.
                results.append(('', time_str, label, v_str, balance_str, tx_hash))
    
                # item = QTreeWidgetItem( [ '', time_str, label, v_str, balance_str] )
                # item.setFont(2, QFont(MONOSPACE_FONT))
                # item.setFont(3, QFont(MONOSPACE_FONT))
                # item.setFont(4, QFont(MONOSPACE_FONT))
                # if value < 0:
                #    item.setForeground(3, QBrush(QColor("#BC1E1E")))
                # if tx_hash:
                #    item.setData(0, Qt.UserRole, tx_hash)
                #    item.setToolTip(0, "%d %s\nTxId:%s" % (conf, _('Confirmations'), tx_hash) )
                # if is_default_label:
                #    item.setForeground(2, QBrush(QColor('grey')))
    
                # item.setIcon(0, icon)
                # self.history_list.insertTopLevelItem(0,item)
    
            return results

        self.history_view.content_adapter.data = \
                parse_histories(reversed(self.wallet.get_tx_history(self.current_account)))

    def create_send_tab(self):
        def add_row(label, input, help):
            hbox = BoxLayout(orientation='horizontal')  # , size_hint_y=None, height='30dp')
            hbox.add_widget(Label(text=label))
            hbox.add_widget(input)
            hbox.add_widget(Button(text="?", size_hint_x=None, width='30dp',
                                   on_press=lambda instance: self.help_box(content_text=help)))
            vbox.add_widget(hbox)

        vbox = BoxLayout(orientation='vertical', size_hint_y=None, height='160dp')

        self.payto_e = TextInput(multiline=False)
        # if DEBUG: self.payto_e.text = '13iB6JbHqJ9efgHTbDcRqewUZeCxywvUxN'
        add_row(_('Pay to'), self.payto_e, _('Recipient of the funds.') + '\n\n' + _('You may enter a Bitcoin address, a label from your list of contacts (a list of completions will be proposed), or an alias (email-like address that forwards to a Bitcoin address)'))

        self.message_e = TextInput(multiline=False)
        add_row(_('Description'), self.message_e, _('Description of the transaction (not mandatory).') + '\n\n' + _('The description is not sent to the recipient of the funds. It is stored in your wallet file, and displayed in the \'History\' tab.'))

        self.amount_e = TextInput(multiline=False)
        # if DEBUG: self.amount_e.text = '0.001'
        add_row(_('Amount'), self.amount_e, _('Amount to be sent.') + '\n\n' \
                    + _('The amount will be displayed in red if you do not have enough funds in your wallet. Note that if you have frozen some of your addresses, the available funds will be lower than your total balance.') \
                    + '\n\n' + _('Keyboard shortcut: type "!" to send all your coins.'))

        self.fee_e = TextInput(multiline=False)
        # if DEBUG: self.fee_e.text = '0.0001'
        add_row(_('Fee'), self.fee_e, _('Bitcoin transactions are in general not free. A transaction fee is paid by the sender of the funds.') + '\n\n'\
                    + _('The amount of fee can be decided freely by the sender. However, transactions with low fees take more time to be processed.') + '\n\n'\
                    + _('A suggested fee is automatically added to this field. You may override it. The suggested fee increases with the size of the transaction.'))

        hbox = BoxLayout(orientation='horizontal', size_hint_y=None, height='40dp')
        if self.wallet.seed:
            b = Button(text=_("Send"), on_press=self.do_send)
        else:
            b = Button(text=_("Create unsigned transaction"), on_press=self.do_send)
        hbox.add_widget(b)

        b = Button(text=_("Clear"), on_press=self.do_clear)
        hbox.add_widget(b)

        vbox.add_widget(hbox)
        return vbox

        # TODO: shortcut Up Down

    def update_completions(self):
        l = []
        for addr, label in self.wallet.labels.items():
            if addr in self.wallet.addressbook:
                l.append(label + '  <' + addr + '>')

        self.run_hook('update_completions', l)
        self.completions = l

    def protected(func):
        return lambda s, *args: s.do_protect(func, args)

    def do_protect(self, func, args):
        _args = args
        def run_func(instance=None, password=None):
            args = (self,) + _args + (password,)
            apply(func, args)

        if self.wallet.use_encryption:
            return self.password_required_dialog(post_ok=run_func)

        return run_func()

    @protected
    def do_send(self, instance, password):
        label = unicode(self.message_e.text)
        r = unicode(self.payto_e.text).strip()

        # label or alias, with address in brackets
        m = re.match('(.*?)\s*\<([1-9A-HJ-NP-Za-km-z]{26,})\>', r)
        to_address = m.group(2) if m else r

        if not is_valid(to_address):
            return self.error_box(content_text=_('Invalid Bitcoin Address') + ':\n' + to_address)

        try:
            amount = self.read_amount(unicode(self.amount_e.text))
        except:
            return self.error_box(content_text=_('Invalid Amount'))
        try:
            fee = self.read_amount(unicode(self.fee_e.text))
        except:
            return self.error_box(content_text=_('Invalid Fee'))

        try:
            tx = self.wallet.mktx([(to_address, amount)], password, fee, account=self.current_account)
        except BaseException, e:
            return self.info_box(content_text=str(e))

        if tx.requires_fee(self.wallet.verifier) and fee < MIN_RELAY_TX_FEE:
            return self.error_box(content_text=_('This transaction requires a higher fee, or it will not be propagated by the network.'))

        self.run_hook('send_tx', tx)

        if label:
            self.set_label(tx.hash(), label)

        if tx.is_complete:
            # h = self.wallet.send_tx(tx)  # async: this doesn't work in Kivy
            h = self.wallet.sendtx(tx)  # sync
            #### TODO: waiting_dialog(lambda: False if self.wallet.tx_event.isSet() else _("Please wait..."))
            status, msg = self.wallet.receive_tx(h)
            if status:
                self.info_box(content_text=_('Payment sent.') + '\n' + msg)
                self.do_clear()
                self.update_contacts_tab()
            else:
                self.error_box(content_text=msg)
        else:
            filename = label + '.txn' if label else 'unsigned_%s.txn' % (time.mktime(time.gmtime()))
            try:
                #### TODO: fileName = self.getSaveFileName(_("Select a transaction filename"), filename, "*.txn")
                with open(fileName, 'w') as f:
                    f.write(json.dumps(tx.as_dict(), indent=4) + '\n')
                #### TODO: QMessageBox.information(self, _('Unsigned transaction created'), _("Unsigned transaction was saved to file:") + " " + fileName, _('OK'))
            except:
                self.error_box(content_text=_('Could not write transaction to file'))

    def set_url(self, url):
        # TODO:
        pass

    def do_clear(self, instance):
        # self.payto_sig.setVisible(False)
        for e in [self.payto_e, self.message_e, self.amount_e, self.fee_e]:
            e.text = ''
            # self.set_frozen(e, False)
        # self.update_status()

    def set_frozen(self, entry, frozen):
        # NOTE: not sure the Kivy has equivalent feature
        pass

    def toggle_freeze(self, addr):
        # TODO
        pass

    def toggle_priority(self, addr):
        # TODO
        pass

    def create_list_tab(self, headers):
        # NOTE: don't need this generic function in Kivy GUI
        pass

    def create_receive_tab(self):
        self.last_instance = None

        def on_context_menu(instance):
            address = instance.parent.children[3].text
            if not address or not is_valid(address): return

            def copy_to_clipboard(_instance):
                Clipboard.put(instance.parent.children[3].text, 'UTF8_STRING')
                if self.last_instance is not None:
                    self.last_instance.clear_widgets()

            def edit_label(_instance):
                def save_label(__instance):
                    if text_input.text:
                        instance.parent.children[2].text = text_input.text
                    dialog.close()

                text = instance.parent.children[2].text
                text_input = TextInput(text=text, size_hint_y=None, height='30dp', multiline=False, focus=True)
                text_input.select_all()
                dialog = Dialog(title=_('Edit label'), size=('600dp', '130dp'))
                dialog.add_content(text_input)
                dialog.add_button(Button(text=_("Cancel"), on_press=lambda instance: dialog.close()))
                dialog.add_button(Button(text=_('OK'), on_press=save_label))
                dialog.open()

                if self.last_instance is not None:
                    self.last_instance.clear_widgets()

            def show_private_key(_instance):
                # NOTE: equivalent to @protected
                def protected_show_private_key(instance=None, password=None):
                    try:
                        pk = self.wallet.get_private_key(address, password)
                    except BaseException, e:
                        self.info_box(content_text=str(e))
                        return

                    dialog = Dialog(title=_('Private key'))
                    dialog.add_content(Label(text='Address'+ ':\n' + address + '\n\n' + _('Private key') + ':\n' + pk))
                    dialog.add_button(Button(text=_('OK'), on_press=lambda instance: dialog.close()))
                    dialog.open()

                if self.wallet.use_encryption:
                    return self.password_required_dialog(post_ok=protected_show_private_key)
                return protected_show_private_key()

            def show_sign_message(_instance):
                def sign_message():
                    vbox = BoxLayout(orientation='vertical')
                    vbox.add_widget(Label(text=_('Address'), size_hint_y=None, height='30dp'))
                    self.sign_address = TextInput(text=address, size_hint_y=None, height='30dp')
                    vbox.add_widget(self.sign_address)
                    vbox.add_widget(Label(text=_('Message'), size_hint_y=None, height='30dp'))
                    self.sign_message = TextInput()
                    vbox.add_widget(self.sign_message)
                    vbox.add_widget(Label(text=_('Signature'), size_hint_y=None, height='30dp'))
                    self.sign_signature = TextInput()
                    vbox.add_widget(self.sign_signature)
                    return vbox

                def verify_message():
                    vbox = BoxLayout(orientation='vertical')
                    vbox.add_widget(Label(text=_('Address'), size_hint_y=None, height='30dp'))
                    self.verify_address = TextInput(size_hint_y=None, height='30dp')
                    vbox.add_widget(self.verify_address)
                    vbox.add_widget(Label(text=_('Message'), size_hint_y=None, height='30dp'))
                    self.verify_message = TextInput()
                    vbox.add_widget(self.verify_message)
                    vbox.add_widget(Label(text=_('Signature'), size_hint_y=None, height='30dp'))
                    self.verify_signature = TextInput()
                    vbox.add_widget(self.verify_signature)
                    return vbox

                def on_ok_press(__instance):
                    if tabs.current_tab.text == _('Sign'):
                        # NOTE: equivalent to @protected
                        def protected_do_sign_message(instance=None, password=None):
                            try:
                                sig = self.wallet.sign_message(self.sign_address.text, self.sign_message.text, password)
                                self.sign_signature.text = sig
                            except BaseException, e:
                                self.info_box(content_text=str(e))

                        if self.wallet.use_encryption:
                            return self.password_required_dialog(post_ok=protected_do_sign_message)
                        return protected_do_sign_message()

                    else:  # _('Verify')
                        if self.wallet.verify_message(self.verify_address.text, self.verify_signature.text, self.verify_message.text):
                            self.info_box(content_text=_("Signature verified"))
                        else:
                            self.info_box(content_text=_("Error: wrong signature"))

                tabs = TabbedPanel(do_default_tab=False)
                self.add_tab(tabs, sign_message(), _('Sign'))
                self.add_tab(tabs, verify_message(), _('Verify'))

                dialog = Dialog(title=_('Sign Message'), size=('400dp', '400dp'))
                dialog.add_content(tabs)
                dialog.add_button(Button(text=_('Close'), on_press=lambda instance: dialog.close()))
                dialog.add_button(Button(text=_('OK'), on_press=on_ok_press))
                dialog.open()

                if self.last_instance is not None:
                    self.last_instance.clear_widgets()
                self.last_instance = instance

            if self.last_instance is not None:
                self.last_instance.clear_widgets()
            self.last_instance = instance

            context_menu = Bubble(orientation='vertical', size_hint=(None, None),
                                  size=('160dp', '160dp'), arrow_pos='bottom_mid')
            context_menu.pos = instance.pos  # TODO: more cases
            context_menu.add_widget(Button(text=_('Copy to clipboard'), on_press=copy_to_clipboard))
            context_menu.add_widget(Button(text=_('Edit label'), on_press=edit_label))
            context_menu.add_widget(Button(text=_('Private key'), on_press=show_private_key))
            context_menu.add_widget(Button(text=_('Sign message'), on_press=show_sign_message))

            if address in self.wallet.imported_keys:
                def delete_imported_key():
                    def on_ok_press(__instance):
                        self.wallet.delete_imported_key(address)
                        self.update_receive_tab()
                        self.update_history_tab()
                    dialog = Dialog(title=_('Delete imported key'))
                    dialog.add_content(Label(text=_("Do you want to remove")+" %s "%addr +_("from your wallet?")))
                    dialog.add_button(Button(text=_('Cancel'), on_press=lambda instance: dialog.close()))
                    dialog.add_button(Button(text=_('OK'), on_press=on_ok_press))
                    dialog.open()

                    if self.last_instance is not None:
                        self.last_instance.clear_widgets()
                    self.last_instance = instance

                context_menu.add_widget(Button(text=_('Remove from wallet'), on_press=delete_imported_key))  # TODO: test more this feature
                # TODO: increase size on context menu

            if self.expert_mode:
                # TODO: show frozen, prioritied rows in different color as original code
                def toggle_freeze(_instance):
                    if address in self.wallet.frozen_addresses:
                        self.wallet.unfreeze(address)
                    else:
                        self.wallet.freeze(address)
                    self.update_receive_tab()
            
                    if self.last_instance is not None:
                        self.last_instance.clear_widgets()
                    self.last_instance = instance

                def toggle_priority(_instance):
                    if address in self.wallet.prioritized_addresses:
                        self.wallet.unprioritize(address)
                    else:
                        self.wallet.prioritize(address)
                    self.update_receive_tab()

                    if self.last_instance is not None:
                        self.last_instance.clear_widgets()
                    self.last_instance = instance

                t = _("Unfreeze") if address in self.wallet.frozen_addresses else _("Freeze")
                context_menu.add_widget(Button(text=t, on_press=toggle_freeze))
                t = _("Unprioritize") if address in self.wallet.prioritized_addresses else _("Prioritize")
                context_menu.add_widget(Button(text=t, on_press=toggle_priority))
                context_menu.height = '240dp'  # TODO: find better way to increase size on context menu
  
            instance.add_widget(context_menu)

        self.receive_list = GridView(
            headers=[_('Address'), _('Label'), _('Balance'), _('Tx')],
            widths=[350, 250, 100, 100],
            on_context_menu=on_context_menu,
        )

        return self.receive_list.layout

    def receive_tab_set_mode(self, i):
        # NOTE: just used once so merged into the caller
        pass

    def save_column_widths(self):
        # NOTE: not used since the widths are fixed now in Kivy GUI
        pass

    def create_contacts_tab(self):
        def new_contact_dialog(instance):
            def save_new_contact(instance):
                address = unicode(text_input.text.strip())
                if is_valid(address):
                    self.wallet.add_contact(address)
                    self.update_contacts_tab()
                    self.update_history_tab()
                    self.update_completions()
                    dialog.close()
                else:
                    self.error_box(content_text=_('Invalid Address'))

            text_input = TextInput(multiline=False)
            dialog = Dialog(title=_('New Contact'))
            dialog.add_content(Label(text=_('Address') + ':'))
            dialog.add_content(text_input)
            dialog.add_button(Button(text=_('Cancel'), on_press=lambda instance: dialog.close()))
            dialog.add_button(Button(text=_('OK'), on_press=save_new_contact))
            dialog.open()

        self.contacts_list = GridView(
            headers=[_('Address'), _('Label'), _('Tx')],
            widths=[350, 250, 200],
        )

        vbox = BoxLayout(orientation='vertical')
        vbox.add_widget(self.contacts_list.layout)
        vbox.add_widget(Button(text=_("New"), size_hint=(0.25, None), height='40dp', on_press=new_contact_dialog))

        # l.setContextMenuPolicy(Qt.CustomContextMenu)
        # l.customContextMenuRequested.connect(self.create_contact_menu)
        # self.connect(l, SIGNAL('itemDoubleClicked(QTreeWidgetItem*, int)'), lambda a, b: self.address_label_clicked(a,b,l,0,1))
        # self.connect(l, SIGNAL('itemChanged(QTreeWidgetItem*, int)'), lambda a,b: self.address_label_changed(a,b,l,0,1))

        return vbox

    def create_console_tab(self):
        from electrum_gui.kivy_console import Console
        self.console = console = Console()
        self.console.history = self.conf.get("console-history", [])
        self.console.history_index = len(self.console.history)

        console.updateNamespace({'wallet' : self.wallet, 'interface' : self.wallet.interface, 'gui':self})
        console.updateNamespace({'util' : util, 'bitcoin':bitcoin})

        c = Commands(self.wallet, self.wallet.interface, lambda: self.console.set_json(True))
        methods = {}
        def mkfunc(f, method):
            return lambda *args: apply(f, (method, args, self.password_required_dialog))
        for m in dir(c):
            if m[0] == '_' or m == 'wallet' or m == 'interface': continue
            methods[m] = mkfunc(c._run, m)

        console.updateNamespace(methods)
        return console

    # NEW
    def add_tab(self, tabs, widget, title):
        tab = TabbedPanelItem(text=title)
        tab.add_widget(widget)
        tabs.add_widget(tab)

    # NEW: extracted from self.__init__()
    def show(self):
        tabs = TabbedPanel(do_default_tab=False)
        self.add_tab(tabs, self.create_history_tab(), _('History'))
        self.add_tab(tabs, self.create_send_tab(), _('Send'))
        self.add_tab(tabs, self.create_receive_tab(), _('Receive'))
        self.add_tab(tabs, self.create_contacts_tab(), _('Contacts'))
        self.add_tab(tabs, self.create_console_tab(), _('Console'))
        self.layout.add_widget(tabs, 2)

        title = 'Electrum ' + self.wallet.electrum_version + '  -  ' + self.conf.path
        if not self.wallet.seed: title += ' [%s]' % (_('seedless'))

        self.app.title = title  # TODO: why not actually update?

        # NOTE: no need shortcut for Kivy GUI

    # NEW
    def create_status_bar(self):
        sb = StatusBar()

        label = Label(halign='left', valign='middle', padding_x='-10dp')
        label.bind(size=label.setter('text_size'))
        self.status_text = label
        sb.add_text(self.status_text)

        # update_notification = UpdateLabel(self.config)
        # if(update_notification.new_version):
        #    sb.addPermanentWidget(update_notification)

        # accounts = self.wallet.get_accounts()
        # if len(accounts) > 1:
        #    from_combo = QComboBox()
        #    from_combo.addItems([_("All accounts")] + accounts.values())
        #    from_combo.setCurrentIndex(0)
        #    self.connect(from_combo, SIGNAL("activated(QString)"), self.change_account)
        #    sb.addPermanentWidget(from_combo)

        if self.wallet.seed:
            self.password_button = Button(text=_("Password"), on_press=self.change_password_dialog)
            sb.add_button(self.password_button)

        self.password_pref = Button(text=_("Preferences"), on_press=self.show_settings_dialog)
        sb.add_button(self.password_pref)

        if self.wallet.seed:
            self.seed_button = Button(text=_("Seed"), on_press=self.protected_seed_dialog)
            sb.add_button(self.seed_button)

        self.status_button = Button(text=_("Network"), on_press=self.change_network_dialog)
        sb.add_button(self.status_button)

        self.run_hook('create_status_bar', (sb,))

        self.layout.add_widget(sb.layout, 1)

    def password_required_dialog(self, post_ok=None):  # renamed from password_dialog()
        def on_ok_press(instance):
            dialog.close()

            password = unicode(pw.text)

            try:
                seed = self.wallet.decode_seed(password)
            except:
                return self.error_box(content_text=_('Incorrect Password'))

            if post_ok is not None:
                post_ok(instance, password)

        pw = TextInput(password=True)
        dialog = Dialog(title=_('Password'))
        dialog.add_content(Label(text=_('Please enter password')))
        dialog.add_content(pw)
        dialog.add_button(Button(text=_("Cancel"), on_press=lambda instance: dialog.close()))
        dialog.add_button(Button(text=_("OK"), on_press=on_ok_press))
        dialog.open()

    @protected
    def protected_seed_dialog(self, instance, password):  # renamed from show_seed_dialog()
        return self.init_seed_dialog(instance, password)

    def tx_dict_from_text(self, txt):
        try:
            tx_dict = json.loads(str(txt))
            assert "hex" in tx_dict.keys()
            assert "complete" in tx_dict.keys()
            if not tx_dict["complete"]:
                assert "input_info" in tx_dict.keys()
        except:
            self.error_box(title="Unable to parse transaction",
                           content_text=_("Electrum was unable to parse your transaction"))
            return None
        return tx_dict

    def update_receive_item(self, item):
        # TODO: can't port completely since there's no corresponding widget
        # item.setFont(0, QFont(MONOSPACE_FONT))
        self.run_hook('update_receive_item', item)

        # c, u = self.wallet.get_addr_balance(address)
        # balance = self.format_amount(c + u)
        # item.setData(2,0,balance)

        # if self.expert_mode:
        #    if address in self.wallet.frozen_addresses:
        #        item.setBackgroundColor(0, QColor('lightblue'))
        #    elif address in self.wallet.prioritized_addresses:
        #        item.setBackgroundColor(0, QColor('lightgreen'))

    def update_receive_tab(self):
        data = []

        if self.current_account is None:
            account_items = self.wallet.accounts.items()
        elif self.current_account != -1:
            account_items = [(self.current_account, self.wallet.accounts.get(self.current_account))]
        else:
            account_items = []

        for k, account in account_items:
            name = account.get('name', str(k))
            c, u = self.wallet.get_account_balance(k)
            data = [(name, '', self.format_amount(c + u), '')]

            for is_change in ([0, 1] if self.expert_mode else [0]):
                if self.expert_mode:
                    name = "Receiving" if not is_change else "Change"
                    seq_item = (name, '', '', '')
                    data.append(seq_item)
                else:
                    seq_item = data
                is_red = False
                gap = 0

                for address in account[is_change]:
                    h = self.wallet.history.get(address, [])

                    if h == []:
                        gap += 1
                        if gap > self.wallet.gap_limit:
                            is_red = True
                    else:
                        gap = 0

                    num_tx = '*' if h == ['*'] else "%d" % len(h)
                    item = (address, self.wallet.labels.get(address, ''), '', num_tx)
                    data.append(item)
                    self.update_receive_item(item)

        if self.wallet.imported_keys and (self.current_account is None or self.current_account == -1):
            c, u = self.wallet.get_imported_balance()
            data.append((_('Imported'), '', self.format_amount(c + u), ''))
            for address in self.wallet.imported_keys.keys():
                item = (address, self.wallet.labels.get(address, ''), '', '')
                data.append(item)
                self.update_receive_item(item)

        self.receive_list.content_adapter.data = data

    def update_contacts_tab(self):
        data = []
        for address in self.wallet.addressbook:
            label = self.wallet.labels.get(address, '')
            item = (address, label, "%d" % self.wallet.get_num_tx(address))
            data.append(item)
            # item.setFont(0, QFont(MONOSPACE_FONT))
            # # 32 = label can be edited (bool)
            # item.setData(0,32, True)
            # # 33 = payto string
            # item.setData(0,33, address)

        self.run_hook('update_contacts_tab')

        self.contacts_list.content_adapter.data = data

    def show_settings_dialog(self, instance):
        SettingsDialog(self, instance)

    def emit(self, signal):
        """Dummy function to avoid call error"""
        pass


class ElectrumApp(App):
    title = _('Electrum App')

    def __init__(self, wallet, conf, *args, **kwargs):
        super(ElectrumApp, self).__init__(*args, **kwargs)
        self.wallet = wallet
        self.conf = conf  # conflicting name 'config'

    def build(self):
        return BoxLayout()

    def on_start(self):
        gui = ElectrumInitGui(app=self)
        if not gui.conf.wallet_file_exists:
            gui.restore_or_create_dialog()
        else:
            gui.load_wallet()


def arg_parser():
    usage = "usage: %prog [options] command\nCommands: " + (', '.join(known_commands))
    parser = optparse.OptionParser(prog=usage)
    parser.add_option("-g", "--gui", dest="gui", help="User interface: qt, lite, gtk or text")
    parser.add_option("-w", "--wallet", dest="wallet_path", help="wallet path (default: electrum.dat)")
    parser.add_option("-o", "--offline", action="store_true", dest="offline", default=False, help="remain offline")
    parser.add_option("-a", "--all", action="store_true", dest="show_all", default=False, help="show all addresses")
    parser.add_option("-b", "--balance", action="store_true", dest="show_balance", default=False, help="show the balance of listed addresses")
    parser.add_option("-l", "--labels", action="store_true", dest="show_labels", default=False, help="show the labels of listed addresses")
    parser.add_option("-f", "--fee", dest="tx_fee", default=None, help="set tx fee")
    parser.add_option("-F", "--fromaddr", dest="from_addr", default=None, help="set source address for payto/mktx. if it isn't in the wallet, it will ask for the private key unless supplied in the format public_key:private_key. It's not saved in the wallet.")
    parser.add_option("-c", "--changeaddr", dest="change_addr", default=None, help="set the change address for payto/mktx. default is a spare address, or the source address if it's not in the wallet")
    parser.add_option("-s", "--server", dest="server", default=None, help="set server host:port:protocol, where protocol is t or h")
    parser.add_option("-p", "--proxy", dest="proxy", default=None, help="set proxy [type:]host[:port], where type is socks4,socks5 or http")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False, help="show debugging information")
    parser.add_option("-P", "--portable", action="store_true", dest="portable", default=False, help="portable wallet")
    parser.add_option("-L", "--lang", dest="language", default=None, help="defaut language used in GUI")
    parser.add_option("-u", "--usb", dest="bitkey", action="store_true", help="Turn on support for hardware wallets (EXPERIMENTAL)")
    return parser


if __name__ == "__main__":
    parser = arg_parser()
    options, args = parser.parse_args()
    if options.portable and options.wallet_path is None:
        options.wallet_path = os.path.dirname(os.path.realpath(__file__)) + '/electrum.dat'
    set_verbosity(options.verbose)

    # config is an object passed to the various constructors (wallet, interface, gui)
    import __builtin__
    __builtin__.use_local_modules = True  # TODO: remove hard-coded

    is_android = False  # TODO: remove hard-coded
    if is_android:
        config_options = {'wallet_path':"/sdcard/electrum.dat", 'portable':True, 'verbose':True, 'gui':'android', 'auto_cycle':True}
    else:
        config_options = eval(str(options))
        for k, v in config_options.items():
            if v is None: config_options.pop(k)

    # Wallet migration on Electrum 1.7
    # Todo: In time we could remove this again
    if platform.system() == "Windows":
        util.check_windows_wallet_migration()

    el_conf = SimpleConfig(config_options)
    el_wallet = Wallet(el_conf)
    el_wallet.interface = Interface(el_conf, True)

    app = ElectrumApp(el_wallet, el_conf)
    app.run()
