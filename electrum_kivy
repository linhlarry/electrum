# TODO: remove
import imp
imp.load_module('electrum', *imp.find_module('lib'))
imp.load_module('electrum_gui', *imp.find_module('gui'))

import os
import sys
import optparse
import platform
import time
import datetime
import re
import json
import traceback
import threading

from pprint import pprint
from decimal import Decimal

from kivy.app import App
from kivy.clock import Clock
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.uix.gridlayout import GridLayout
from kivy.uix.spinner import Spinner
from kivy.uix.treeview import TreeView, TreeViewLabel
from kivy.uix.checkbox import CheckBox
from kivy.uix.tabbedpanel import TabbedPanel, TabbedPanelItem
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.listview import ListItemButton, ListItemLabel, CompositeListItem, \
    ListView
from kivy.adapters.dictadapter import DictAdapter
from kivy.adapters.listadapter import ListAdapter

from electrum import mnemonic, util
from electrum.interface import DEFAULT_PORTS, Interface
from electrum.simple_config import SimpleConfig
from electrum.wallet import Wallet, WalletSynchronizer
from electrum.util import set_verbosity, format_satoshis, print_error, print_msg
from electrum.commands import known_commands
from electrum.verifier import WalletVerifier
from electrum.bitcoin import is_valid, MIN_RELAY_TX_FEE

_ = lambda x: x

DEBUG = True

if DEBUG:
    MIN_RELAY_TX_FEE = 0


class Dialog(object):
    def __init__(self, title, size_hint=(None, None), size=('400dp', '300dp'),
                 content_padding='0dp', buttons_padding='0dp', buttons_height='40dp'):

        layout_content = BoxLayout(orientation='vertical', padding=content_padding)

        layout_buttons = BoxLayout(orientation='horizontal', size_hint=(1, None),
                                   height=buttons_height, padding=buttons_padding)

        layout = BoxLayout(orientation='vertical')
        layout.add_widget(layout_content)
        layout.add_widget(layout_buttons)

        dialog = Popup(title=title,
                       content=layout,
                       size_hint=size_hint,
                       size=size,
                       auto_dismiss=False)

        self.layout_content = layout_content
        self.layout_buttons = layout_buttons
        self.dialog = dialog

    def open(self):
        self.dialog.open()

    def close(self):
        self.dialog.dismiss()

    def add_content(self, widget, index=0):
        self.layout_content.add_widget(widget, index)

    def add_button(self, widget, index=0):
        self.layout_buttons.add_widget(widget, index)


class StatusBar(object):
    def __init__(self, height='40dp', text_height='38dp', button_height='38dp'):
        layout_text = BoxLayout(orientation='horizontal', size_hint=(1, None), height=text_height)
        layout_buttons = BoxLayout(orientation='horizontal', size_hint=(1, None), height=button_height)

        layout = BoxLayout(orientation='vertical', size_hint=(1, None), height=height)
        layout.add_widget(layout_text)
        layout.add_widget(layout_buttons)

        self.layout = layout
        self.layout_text = layout_text
        self.layout_buttons = layout_buttons

    def add_text(self, widget, index=0):
        self.layout_text.add_widget(widget, index)

    def add_button(self, widget, index=0):
        self.layout_buttons.add_widget(widget, index)


class ElectrumGui(object):
    def __init__(self, app):
        self.app = app
        self.wallet = app.wallet
        self.conf = app.conf

    def _message_box(self, title, content_text, button_text=_("OK"), callback=None):
        dialog = Dialog(title, size=('400dp', '200dp'))
        if callback is None:
            callback = lambda instance: dialog.close()
        label = Label(text=content_text)
        label.bind(size=label.setter('text_size'))
        dialog.add_content(label)
        dialog.add_button(Button(text=button_text, on_press=callback))
        dialog.open()
        return dialog

    def info_box(self, title=_("Info"), content_text=_("More info"), button_text=_("OK")):
        return self._message_box(title, content_text, button_text)

    def help_box(self, title=_("Help"), content_text=_("More help"), button_text=_("OK")):
        return self._message_box(title, content_text, button_text)

    def error_box(self, title=_("Error"), content_text=_("Error info"), button_text=_("OK")):
        return self._message_box(title, content_text, button_text)

    def exit_box(self, title=_("Error"), content_text=_("Error info"), button_text=_("OK")):
        return self._message_box(title, content_text, button_text, callback=lambda instance: self.app.stop())

    def change_password_dialog(self, instance=None):
        """Can be called directly (instance is None)
        or from a callback (instance is not None)"""
        wallet = self.wallet

        if not wallet.seed:
            return self.exit_box(content_text=_('No seed'))

        dialog = Dialog(title=_('Password'))

        pw = TextInput(password=True)
        new_pw = TextInput(password=True)
        conf_pw = TextInput(password=True)

        if instance:
            msg = (_('Your wallet is encrypted. Use this dialog to change your password.') + '\n'\
                   + _('To disable wallet encryption, enter an empty new password.')) \
                   if wallet.use_encryption else _('Your wallet keys are not encrypted')
        else:
            msg = _("Please choose a password to encrypt your wallet keys.") + '\n'\
                  + _("Leave these fields empty if you want to disable encryption.")
        dialog.add_content(Label(text=msg))

        grid = GridLayout(cols=2)
        # grid.setSpacing(8)

        if wallet.use_encryption:
            grid.add_widget(Label(text=_('Password')))
            grid.add_widget(pw)

        grid.add_widget(Label(text=_('New Password')))
        grid.add_widget(new_pw)

        grid.add_widget(Label(text=_('Confirm Password')))
        grid.add_widget(conf_pw)

        dialog.add_content(grid)

        def on_cancel_click(instance):
            dialog.close()
            # self.load_wallet()

        def on_ok_click(instance):
            password = unicode(pw.text) if wallet.use_encryption else None
            new_password = unicode(new_pw.text)
            new_password2 = unicode(conf_pw.text)

            try:
                seed = wallet.decode_seed(password)
            except:
                return self.error_box(content_text=_('Incorrect Password'))

            if new_password != new_password2:
                return self.error_box(content_text=_('Passwords do not match'))

            # TODO: test carefully
            try:
                wallet.update_password(seed, password, new_password)
            except:
                return self.exit_box(content_text=_('Failed to update password'))
            else:
                self.info_box(title=_('Success'), content_text=_('Password was updated successfully'))

            # TODO: review
            # if parent:
            #    icon = QIcon(":icons/lock.png") if wallet.use_encryption else QIcon(":icons/unlock.png")
            #    parent.password_button.setIcon( icon )

            dialog.close()
            # self.load_wallet()
            # TODO: can not load the main window here. Must restart.

        button_cancel = Button(text=_("Cancel"), on_press=on_cancel_click)
        button_ok = Button(text=_("OK"), on_press=on_ok_click)

        dialog.add_button(button_cancel)
        dialog.add_button(button_ok)

        dialog.open()

    def show_seed(self, seed, imported_keys, parent=None):
        dialog = Dialog(title='Electrum' + ' - ' + _('Seed'), size=('400dp', '400dp'))

        brainwallet = ' '.join(mnemonic.mn_encode(seed))

        label1 = Label(text=_("Your wallet generation seed is") + ":")
        label1.bind(size=label1.setter('text_size'))

        if DEBUG:
            seed_text = TextInput(text=brainwallet, size_hint=(1, 2), multiline=True, readonly=False)  # allow copy-paste
        else:
            seed_text = TextInput(text=brainwallet, size_hint=(1, 2), multiline=True, readonly=True)

        # seed_text.setMaximumHeight(130)

        msg2 = _("Please write down or memorize these 12 words (order is important).") + " " \
              + _("This seed will allow you to recover your wallet in case of computer failure.") + " " \
              + _("Your seed is also displayed as QR code, in case you want to transfer it to a mobile phone.") + "\n" \
              + "[b]" + _("WARNING") + ":[/b] " + _("Never disclose your seed. Never type it on a website.")
        if imported_keys:
            msg2 += "[b]" + _("WARNING") + ":[/b] " + _("Your wallet contains imported keys. These keys cannot be recovered from seed.")
        label2 = Label(text=msg2, size_hint=(1, 4), valign='top', markup=True)
        label2.bind(size=label2.setter('text_size'))

        # TODO: add this
#         logo = QLabel()
#         logo.setPixmap(QPixmap(":icons/seed.png").scaledToWidth(56))
#         logo.setMaximumWidth(60)
#
#         qrw = QRCodeWidget(seed)
#
#         ok_button = QPushButton(_("OK"))
#         ok_button.setDefault(True)
#         ok_button.clicked.connect(dialog.accept)
#
#         grid = QGridLayout()
#         #main_layout.addWidget(logo, 0, 0)
#
#         grid.addWidget(logo, 0, 0)
#         grid.addWidget(label1, 0, 1)
#
#         grid.addWidget(seed_text, 1, 0, 1, 2)
#
#         grid.addWidget(qrw, 0, 2, 2, 1)
#
#         vbox = QVBoxLayout()
#         vbox.addLayout(grid)
#         vbox.addWidget(label2)

        def on_ok_click(instance):
            dialog.close()
            try:
                self.verify_seed()  # just for ElectrumSetupGui
            except AttributeError:
                pass

        button_ok = Button(text=_("OK"), on_press=on_ok_click)

        dialog.add_content(label1)
        dialog.add_content(seed_text)
        dialog.add_content(label2)
        dialog.add_button(button_ok)
        dialog.open()


class ElectrumSetupGui(ElectrumGui):
    def __init__(self, app):
        super(ElectrumSetupGui, self).__init__(app)
        self.action = None  # updated by self.restore_or_create()

    def restore_or_create(self):
        msg = _("Wallet file not found.") + "\n" + _("Do you want to create a new wallet, or to restore an existing one?")
        dialog = Dialog(title=_('Message'))

        label = Label(text=msg, valign='middle')
        label.bind(size=label.setter('text_size'))

        def on_create_click(instance):
            self.action = 'create'
            dialog.close()
            self.wallet.init_seed(None)
            self.show_seed(self.wallet.seed, self.wallet.imported_keys)

        def on_restore_click(instance):
            self.action = 'restore'
            dialog.close()
            self.seed_dialog(True)

        def on_cancel_click(instance):
            self.action = 'cancel'
            dialog.close()
            self.app.stop()

        button_create = Button(text=_('Create'), on_press=on_create_click)
        button_restore = Button(text=_('Restore'), on_press=on_restore_click)
        button_cancel = Button(text=_('Cancel'), on_press=on_cancel_click)

        dialog.add_content(label)
        dialog.add_button(button_create)
        dialog.add_button(button_restore)
        dialog.add_button(button_cancel)

        dialog.open()

    def verify_seed(self):
        return self.seed_dialog(False)

    def seed_dialog(self, is_restore=True):
        dialog = Dialog(title=_("Seed confirmation"))

        vbox = BoxLayout(orientation='vertical')
        if is_restore:
            msg = _("Please enter your wallet seed (or your master public key if you want to create a watching-only wallet)." + ' ')
        else:
            msg = _("Your seed is important! To make sure that you have properly saved your seed, please type it here." + ' ')

        msg += _("Your seed can be entered as a sequence of words, or as a hexadecimal string." + '\n')

        label = Label(text=msg)
        label.bind(size=label.setter('text_size'))
        vbox.add_widget(label)

        seed_e = TextInput()
        if DEBUG:
            seed_e = TextInput(text=self.wallet.seed)  # auto fill
        # seed_e.setMaximumHeight(100)
        vbox.add_widget(seed_e)

        if is_restore:
            grid = GridLayout(cols=3, size_hint=(1, 0.5), row_force_default=True, row_default_height='40dp')
            # grid.setSpacing(8)

            msg = _('Keep the default value unless you modified this parameter in your wallet.')
            gap_e = TextInput(text="5", multiline=False)
            grid.add_widget(Label(text=_('Gap limit'), size_hint_x=None, width='80dp'))
            grid.add_widget(gap_e)
            grid.add_widget(Button(text="?", size_hint_x=None, width='40dp',
                                   on_press=lambda instance: self.help_box(content_text=msg)))
            vbox.add_widget(grid)

        def on_cancel_click(instance):
            dialog.close()
            self.app.stop()

        def on_ok_click(instance):
            dialog.close()

            seed = seed_e.text

            try:
                seed.decode('hex')
            except:
                try:
                    seed = mnemonic.mn_decode(seed.split())
                except:
                    return self.exit_box(content_text=_('I cannot decode this'))

            if not seed:
                return self.exit_box(content_text=_('No seed'))

            if not is_restore:
                if seed != self.wallet.seed:
                    return self.exit_box(content_text=_('Incorrect seed'))
                self.wallet.save_seed()
                return self.network_dialog(self.wallet)
            else:
                try:
                    gap = int(unicode(gap_e.text))
                except:
                    return self.exit_box(content_text=_('Gap must be an integer'))

                wallet = self.wallet
                wallet.gap_limit = gap
                if len(seed) == 128:
                    wallet.seed = ''
                    wallet.init_sequence(str(seed))
                else:
                    wallet.init_seed(str(seed))
                    wallet.save_seed()

                return self.network_dialog(self.wallet, None)

        button_cancel = Button(text=_("Cancel"), on_press=on_cancel_click)
        button_ok = Button(text=_("OK"), on_press=on_ok_click)

        dialog.add_content(vbox)
        dialog.add_button(button_cancel)
        dialog.add_button(button_ok)

        dialog.open()

    def network_dialog(self, wallet, parent=None):
        # TODO: rewrite this function since the original code became class based rather than function based
        interface = wallet.interface
        if parent:
            if interface.is_connected:
                status = _("Connected to") + " %s\n%d " % (interface.host, wallet.verifier.height) + _("blocks")
            else:
                status = _("Not connected")
            server = interface.server
        else:
            # import random
            status = _("Please choose a server.") + "\n" + _("Select 'Cancel' if you are offline.")
            server = interface.server

        servers = interface.get_servers()

        dialog = Dialog(title=_('Server'), size=('400dp', '600dp'))
        # d.setMinimumSize(375, 20)

        # grid layout
        grid = GridLayout(cols=4)
        # grid.setSpacing(8)

        # server
        server_host = TextInput(multiline=False, size_hint=(1, 0.5))
        server_port = TextInput(multiline=False, size_hint=(1, 0.5))

        protocol_names = ['TCP', 'HTTP', 'SSL', 'HTTPS']
        protocol_letters = 'thsg'

        # TODO: add icons/network.png

        server_protocol = Spinner(
            text='HTTP',
            values=protocol_names,
            size_hint=(None, None),
            size=(100, 44),
            pos_hint={'center_x': .5, 'center_y': .5})

        def on_change_protocol(instance, protocol_name):
            # TODO: improve this function
            try:
                index = protocol_names.index(protocol_name)
            except ValueError:
                index = 0
            p = protocol_letters[index]
            host = unicode(self.server_host.text)
            pp = servers.get(host)
            if p not in pp.keys():
                p = pp.keys()[0]
            port = pp[p]
            server_host.text = host
            server_port.text = port
            # self.set_protocol(p)


        server_protocol.bind(text=on_change_protocol)

        label = _('Active Servers') if wallet.interface.servers else _('Default Servers')

        def change_server(host, protocol=None):
            pp = servers.get(host, DEFAULT_PORTS)
            if protocol:
                port = pp.get(protocol)
                if not port: protocol = None

            if not protocol:
                if 's' in pp.keys():
                    protocol = 's'
                    port = pp.get(protocol)
                else:
                    protocol = pp.keys()[0]
                    port = pp.get(protocol)

            server_host.text = host
            server_port.text = port
            # TODO
            # server_protocol.setCurrentIndex(protocol_letters.index(protocol))

            if not servers: return

            # TODO: what's this?
#             for p in protocol_letters:
#                 i = protocol_letters.index(p)
#                 j = server_protocol.model().index(i,0)
#                 if p not in pp.keys() and interface.is_connected:
#                     server_protocol.model().setData(j, QtCore.QVariant(0), QtCore.Qt.UserRole-1)
#                 else:
#                     server_protocol.model().setData(j, QtCore.QVariant(33), QtCore.Qt.UserRole-1)

        if server:
            host, port, protocol = server.split(':')
            change_server(host, protocol)

        servers_list_widget = TreeView(hide_root=True, size_hint=(1, None), height='100dp')
        # servers_list_widget.bind(minimum_height = servers_list_widget.setter('height'))
        # servers_list_widget.setHeaderLabels( [ label, _('Limit') ] )
        # servers_list_widget.setMaximumHeight(150)
        # servers_list_widget.setColumnWidth(0, 240)

        for _host in servers.keys():
            servers_list_widget.add_node(TreeViewLabel(text=_host))
            # TODO: review it
            # pruning_level = servers_list[_host].get('pruning','')
            # servers_list_widget.addTopLevelItem(QTreeWidgetItem( [ _host, pruning_level ] ))
        # servers_list_widget.setColumnHidden(1, not parent.expert_mode if parent else True)

        # servers_list_widget.connect(servers_list_widget, SIGNAL('currentItemChanged(QTreeWidgetItem*,QTreeWidgetItem*)'),
        #                            lambda x,y: change_server(unicode(x.text(0))))

        # TODO: review it
        # if not wallet.config.is_modifiable('server'):
        #    for w in [server_host, server_port, server_protocol, servers_list_widget]: w.setEnabled(False)

        # auto cycle
        layout_autocycle = BoxLayout(orientation='horizontal')
        autocycle_cb = CheckBox(size_hint=(None, 1), width='40dp')
        autocycle_cb.active = wallet.config.get('auto_cycle', True)
        if not wallet.config.is_modifiable('auto_cycle'): autocycle_cb.active = False
        layout_autocycle.add_widget(autocycle_cb)
        layout_autocycle.add_widget(Label(text=_('Try random servers if disconnected')))

        # TODO: add proxy
#         # proxy setting
#         proxy_mode = QComboBox()
#         proxy_host = QLineEdit()
#         proxy_host.setFixedWidth(200)
#         proxy_port = QLineEdit()
#         proxy_port.setFixedWidth(60)
#         proxy_mode.addItems(['NONE', 'SOCKS4', 'SOCKS5', 'HTTP'])
#
#         def check_for_disable(index = False):
#             if proxy_mode.currentText() != 'NONE':
#                 proxy_host.setEnabled(True)
#                 proxy_port.setEnabled(True)
#             else:
#                 proxy_host.setEnabled(False)
#                 proxy_port.setEnabled(False)
#
#         check_for_disable()
#         proxy_mode.connect(proxy_mode, SIGNAL('currentIndexChanged(int)'), check_for_disable)
#
#         if not wallet.config.is_modifiable('proxy'):
#             for w in [proxy_host, proxy_port, proxy_mode]: w.setEnabled(False)
#
#         proxy_config = interface.proxy if interface.proxy else { "mode":"none", "host":"localhost", "port":"8080"}
#         proxy_mode.setCurrentIndex(proxy_mode.findText(str(proxy_config.get("mode").upper())))
#         proxy_host.setText(proxy_config.get("host"))
#         proxy_port.setText(proxy_config.get("port"))
#
#         grid.addWidget(QLabel(_('Proxy') + ':'), 2, 0)
#         grid.addWidget(proxy_mode, 2, 1)
#         grid.addWidget(proxy_host, 2, 2)
#         grid.addWidget(proxy_port, 2, 3)
#
#         # buttons
#         vbox.addLayout(ok_cancel_buttons(d))
#         d.setLayout(vbox)
#
#         if not d.exec_(): return
#
#         server = unicode( server_host.text ) + ':' + unicode( server_port.text ) + ':' + (protocol_letters[server_protocol.currentIndex()])
#         if proxy_mode.currentText() != 'NONE':
#             proxy = { u'mode':unicode(proxy_mode.currenttext).lower(), u'host':unicode(proxy_host.text), u'port':unicode(proxy_port.text) }
#         else:
#             proxy = None

        self.host = server_host
        self.port = server_port
        print server_host
        print server_port

        def on_cancel_click(instance):
            dialog.close()

            interface.start(wait=False)
            interface.send([('server.peers.subscribe', [])])

            # generate the first addresses, in case we are offline
            wallet.synchronize()

            verifier = WalletVerifier(interface, self.conf)
            verifier.start()
            wallet.set_verifier(verifier)
            synchronizer = WalletSynchronizer(wallet, self.conf)
            synchronizer.start()

            self.change_password_dialog()

        def on_ok_click(instance):
            dialog.close()
            # wallet.config.set_key("proxy", proxy, True)
            wallet.config.set_key("server", server, True)
            # interface.set_server(server, proxy)
            wallet.config.set_key('auto_cycle', autocycle_cb.active, True)

            interface.start(wait=False)
            interface.send([('server.peers.subscribe', [])])

            # generate the first addresses, in case we are offline
            if self.action == 'create':
                wallet.synchronize()

            verifier = WalletVerifier(interface, self.conf)
            verifier.start()
            wallet.set_verifier(verifier)
            synchronizer = WalletSynchronizer(wallet, self.conf)
            synchronizer.start()

            if self.action == 'restore':
                try:
                    keep_it = self.restore_wallet()
                    wallet.fill_addressbook()
                except:
                    import traceback
                    traceback.print_exc(file=sys.stdout)
                    self.app.stop()

                if not keep_it: self.app.stop()

            self.change_password_dialog()

        button_cancel = Button(text=_("Cancel"), on_press=on_cancel_click)
        button_ok = Button(text=_("OK"), on_press=on_ok_click)

        dialog.add_content(Label(text=status))
        dialog.add_content(server_protocol)
        dialog.add_content(server_host)
        dialog.add_content(server_port)
        # dialog.add_content(servers_list_widget)
        dialog.add_content(layout_autocycle)
        dialog.add_button(button_cancel)
        dialog.add_button(button_ok)
        dialog.open()

    def restore_wallet(self):
        return True  # TODO

        wallet = self.wallet
        # wait until we are connected, because the user might have selected another server
        if not wallet.interface.is_connected:
            waiting = lambda: False if wallet.interface.is_connected else "%s \n" % (_("Connecting..."))
            waiting_dialog(waiting)

        waiting = lambda: False if wallet.is_up_to_date() else "%s\n%s %d\n%s %.1f"\
            % (_("Please wait..."), _("Addresses generated:"), len(wallet.addresses(True)), _("Kilobytes received:"), wallet.interface.bytes_received / 1024.)

        wallet.set_up_to_date(False)
        wallet.interface.poke('synchronizer')
        waiting_dialog(waiting)
        if wallet.is_found():
            print_error("Recovery successful")
        else:
            QMessageBox.information(None, _('Error'), _("No transactions found for this seed"), _('OK'))

        return True

    def load_wallet(self):
        interface.start(wait=False)
        interface.send([('server.peers.subscribe', [])])

        verifier = WalletVerifier(interface, self.conf)
        verifier.start()
        self.wallet.set_verifier(verifier)
        synchronizer = WalletSynchronizer(self.wallet, self.conf)
        synchronizer.start()

        url = None  # TODO:
        # self.wallet.save()
        self.main(url)
        # self.wallet.save()

        verifier.stop()
        synchronizer.stop()
        interface.stop()

        # we use daemon threads, their termination is enforced.
        # this sleep command gives them time to terminate cleanly.
        time.sleep(0.1)

    def main(self, url):  # TODO:
        main_gui = ElectrumMainGui(self.app)
        main_gui.show()
        main_gui.connect_slots()
        main_gui.update_wallet()



class ElectrumMainGui(ElectrumGui):
    def __init__(self, app):
        super(ElectrumMainGui, self).__init__(app)

        self.layout = BoxLayout(orientation='vertical')
        self.app.root.add_widget(self.layout)

        self.current_account = app.conf.get("current_account", None)

        self.init_plugins()
        self.create_status_bar()

        self.need_update = threading.Event()
        self.wallet.interface.register_callback('updated', lambda: self.need_update.set())
        self.wallet.interface.register_callback('banner', lambda: lambda: self.console.showMessage(self.wallet.interface.banner))
        self.wallet.interface.register_callback('disconnected', self.update_status)
        self.wallet.interface.register_callback('disconnecting', self.update_status)

        self.expert_mode = app.conf.get('classic_expert_mode', False)
        self.decimal_point = app.conf.get('decimal_point', 8)

        #### set_language(self.conf.get('language'))

        self.funds_error = False
        #### self.completions = QStringListModel()

        #### self.column_widths = self.conf.get("column_widths", default_column_widths)  # NOTE: not used in Kivy now

        #### self.exchanger = exchange_rate.Exchanger(self)
        #### self.connect(self, SIGNAL("refresh_balance()"), self.update_wallet)

        # set initial message
        #### self.console.showMessage(self.wallet.interface.banner)

        # plugins that need to change the GUI do it here
        self.run_hook('init_gui')

    def init_plugins(self):
        # NOTE: Kivy GUI doesn't has any plugin now
        pass

    def run_hook(self, name, *args):
        # NOTE: It just depends on plugins which not exist in Kivy GUI now
        return

    def set_label(self, name, text=None):
        """Update labels in list"""
        changed = False
        old_text = self.wallet.labels.get(name)
        if text:
            if old_text != text:
                self.wallet.labels[name] = text
                changed = True
        else:
            if old_text:
                self.wallet.labels.pop(name)
                changed = True
        self.run_hook('set_label', name, text, changed)
        return changed

    def getOpenFileName(self, title, filter=None):
        # TODO:
        pass

    def getSaveFileName(self, title, filename, filter=None):
        # TODO:
        pass

    def close(self):
        self.app.stop()
        self.run_hook('close_main_window')

    def connect_slots(self):
        Clock.schedule_interval(self.timer_actions, 0.5)
        #self.previous_payto_e = ''  # For plugins only

    def timer_actions(self, interval):
        # print 'timer_actions', datetime.datetime.now()
        if self.need_update.is_set():
            self.update_wallet()
            self.need_update.clear()
        self.run_hook('timer_actions')

    def format_amount(self, x, is_diff=False):
        return format_satoshis(x, is_diff, self.wallet.num_zeros, self.decimal_point)

    def read_amount(self, x):
        if x in['.', '']: return None
        p = pow(10, self.decimal_point)
        return int(p * Decimal(x))

    def base_unit(self):
        assert self.decimal_point in [5, 8]
        return "BTC" if self.decimal_point == 8 else "mBTC"

    def update_status(self):
        if self.wallet.interface and self.wallet.interface.is_connected:
            if not self.wallet.up_to_date:
                text = _("Synchronizing...")
                # icon = QIcon(":icons/status_waiting.png")
            else:
                c, u = self.wallet.get_account_balance(self.current_account)
                text = _("Balance") + ": %s " % (self.format_amount(c)) + self.base_unit()
                if u: text += " [%s unconfirmed]" % (self.format_amount(u, True).strip())
                text += self.create_quote_text(Decimal(c + u) / 100000000)
                # icon = QIcon(":icons/status_connected.png")
        else:
            text = _("Not connected")
            # icon = QIcon(":icons/status_disconnected.png")

        self.status_text = text
        # self.statusBar().showMessage(text)
        # self.status_button.setIcon(icon)

    def update_wallet(self):
        self.update_status()
        if self.wallet.up_to_date or not self.wallet.interface.is_connected:
            self.update_history_tab()
            #self.update_receive_tab()
            #self.update_contacts_tab()
            #self.update_completions()

    def create_quote_text(self, btc_balance):
        quote_currency = self.config.get("currency", "None")
        quote_balance = self.exchanger.exchange(btc_balance, quote_currency)
        if quote_balance is None:
            quote_text = ""
        else:
            quote_text = "  (%.2f %s)" % (quote_balance, quote_currency)
        return quote_text

    def create_history_tab(self):
        # TODO: rewrite parse function
        def parse(item):
            # tx_hash, conf, is_mine, value, fee, balance, timestamp
            tx_hash, conf, is_mine, value, fee, balance, timestamp = item
            if conf > 0:
                try:
                    time_str = datetime.datetime.fromtimestamp(timestamp).isoformat(' ')[:-3]
                except:
                    time_str = "unknown"

            if conf == -1:
                time_str = 'unverified'
                # icon = QIcon(":icons/unconfirmed.png")
            elif conf == 0:
                time_str = 'pending'
                # icon = QIcon(":icons/unconfirmed.png")
            elif conf < 6:
                # icon = QIcon(":icons/clock%d.png"%conf)
                pass
            else:
                # icon = QIcon(":icons/confirmed.png")
                pass

            if value is not None:
                v_str = self.format_amount(value, True)
            else:
                v_str = '--'

            balance_str = self.format_amount(balance)

            if tx_hash:
                label, is_default_label = self.wallet.get_label(tx_hash)
            else:
                label = _('Pruned transaction outputs')
                is_default_label = False

            return '', time_str, label, v_str, balance_str

            # item = QTreeWidgetItem( [ '', time_str, label, v_str, balance_str] )
            # item.setFont(2, QFont(MONOSPACE_FONT))
            # item.setFont(3, QFont(MONOSPACE_FONT))
            # item.setFont(4, QFont(MONOSPACE_FONT))
            # if value < 0:
            #    item.setForeground(3, QBrush(QColor("#BC1E1E")))
            # if tx_hash:
            #    item.setData(0, Qt.UserRole, tx_hash)
            #    item.setToolTip(0, "%d %s\nTxId:%s" % (conf, _('Confirmations'), tx_hash) )
            # if is_default_label:
            #    item.setForeground(2, QBrush(QColor('grey')))

            # item.setIcon(0, icon)
            # self.history_list.insertTopLevelItem(0,item)

        column_width = ['%sdp' % i for i in [50, 150, 400, 100, 100]]

        # For header
        header_text = [("", _("Date"), _("Description"), _("Amount"), _("Balance"))]

        args_header_converter = lambda row_index, item: \
            {'height': '40dp',
             'cls_dicts': [
                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'selected_color': [1, 1, 1, 1],
                                       'size_hint': (None, None),
                                       'width': column_width[0],
                                       'height': '40dp',
                                       'text': item[0]}},

                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'selected_color': [1, 1, 1, 1],
                                       'size_hint': (None, None),
                                       'width': column_width[1],
                                       'height': '40dp',
                                       'text': item[1]}},

                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'selected_color': [1, 1, 1, 1],
                                       'size_hint': (None, None),
                                       'width': column_width[2],
                                       'height': '40dp',
                                       'text': item[2]}},

                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'selected_color': [1, 1, 1, 1],
                                       'size_hint': (None, None),
                                       'width': column_width[3],
                                       'height': '40dp',
                                       'text': item[3]}},

                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'selected_color': [1, 1, 1, 1],
                                       'size_hint': (None, None),
                                       'width': column_width[4],
                                       'height': '40dp',
                                       'text': item[4]}},
                           ]
                 }

        list_header_adapter = ListAdapter(data=header_text,
                                   args_converter=args_header_converter,
                                   selection_mode='single',
                                   allow_empty_selection=False,
                                   cls=CompositeListItem)

        # For content of list
        args_converter = lambda row_index, item: \
            {'height': '30dp',
             'cls_dicts': [
                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'size_hint': (None, None),
                                       'width': column_width[0],
                                       'height': '40dp',
                                       'text': unicode(parse(item)[0])}},

                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'size_hint': (None, None),
                                       'width': column_width[1],
                                       'height': '40dp',
                                       'text': unicode(parse(item)[1])}},

                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'size_hint': (None, None),
                                       'width': column_width[2],
                                       'height': '40dp',
                                       'text': unicode(parse(item)[2])}},

                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'size_hint': (None, None),
                                       'width': column_width[3],
                                       'height': '40dp',
                                       'text': unicode(parse(item)[3])}},

                           {'cls': ListItemButton,
                            'kwargs': {'halign': 'left',
                                       'size_hint': (None, None),
                                       'width': column_width[4],
                                       'height': '40dp',
                                       'text': unicode(parse(item)[4])}},
                           ]
                 }

        history_data = reversed(self.wallet.get_tx_history(self.current_account))

        self.list_adapter = ListAdapter(data=history_data,
                                   args_converter=args_converter,
                                   selection_mode='single',
                                   allow_empty_selection=False,
                                   cls=CompositeListItem)

        # Layout
        header_box = BoxLayout(orientation='vertical', size_hint=(1, None), height='40dp')
        list_header_view = ListView(adapter=list_header_adapter)
        header_box.add_widget(list_header_view)

        content_box = BoxLayout(orientation='vertical')
        list_view = ListView(adapter=self.list_adapter)
        content_box.add_widget(list_view)

        box_layout = BoxLayout(orientation='vertical', padding=['0dp', '2dp'])
        box_layout.add_widget(header_box)
        box_layout.add_widget(content_box)

        return box_layout

    def create_history_menu(self, position):
        # NOTE: no context menu for Kivy now
        pass

    def show_tx_details(self, tx):
        # NOTE: depend on self.create_history_menu()
        pass

    def tx_label_clicked(self, item, column):
        # TODO: depend on self.create_history_tab() and self.create_history_menu()
        pass

    def tx_label_changed(self, item, column):
        # NOTE: depend on self.create_history_menu()
        pass

    def edit_label(self, is_recv):
        # TODO:
        pass

    def address_label_clicked(self, item, column, l, column_addr, column_label):
        # TODO:
        pass

    def address_label_changed(self, item, column, l, column_addr, column_label):
        # TODO:
        pass

    def current_item_changed(self, item):
        self.run_hook('current_item_changed', item)

    def update_history_tab(self):
        self.list_adapter.data = reversed(self.wallet.get_tx_history(self.current_account))

    def create_send_tab(self):
        def add_row(label, input, help):
            hbox = BoxLayout(orientation='horizontal', size_hint_y=None, height='40dp')
            hbox.add_widget(Label(text=label))
            hbox.add_widget(input)
            hbox.add_widget(Button(text="?", size_hint_x=None, width='40dp',
                                   on_press=lambda instance: self.help_box(content_text=help)))
            vbox.add_widget(hbox)

        vbox = BoxLayout(orientation='vertical', size_hint=(1, 0.5))

        self.payto_e = TextInput(multiline=False)
        if DEBUG: self.payto_e.text = '13iB6JbHqJ9efgHTbDcRqewUZeCxywvUxN'
        add_row(_('Pay to'), self.payto_e, _('Recipient of the funds.') + '\n\n' + _('You may enter a Bitcoin address, a label from your list of contacts (a list of completions will be proposed), or an alias (email-like address that forwards to a Bitcoin address)'))

        self.message_e = TextInput(multiline=False)
        add_row(_('Description'), self.message_e, _('Description of the transaction (not mandatory).') + '\n\n' + _('The description is not sent to the recipient of the funds. It is stored in your wallet file, and displayed in the \'History\' tab.'))

        self.amount_e = TextInput(multiline=False)
        if DEBUG: self.amount_e.text = '0.000001'
        add_row(_('Amount'), self.amount_e, _('Amount to be sent.') + '\n\n' \
                    + _('The amount will be displayed in red if you do not have enough funds in your wallet. Note that if you have frozen some of your addresses, the available funds will be lower than your total balance.') \
                    + '\n\n' + _('Keyboard shortcut: type "!" to send all your coins.'))

        self.fee_e = TextInput(multiline=False)
        if DEBUG: self.fee_e.text = '0'
        add_row(_('Fee'), self.fee_e, _('Bitcoin transactions are in general not free. A transaction fee is paid by the sender of the funds.') + '\n\n'\
                    + _('The amount of fee can be decided freely by the sender. However, transactions with low fees take more time to be processed.') + '\n\n'\
                    + _('A suggested fee is automatically added to this field. You may override it. The suggested fee increases with the size of the transaction.'))

        hbox = BoxLayout(orientation='horizontal', size_hint_y=None, height='40dp')
        if self.wallet.seed:
            b = Button(text=_("Send"), on_press=self.do_send)
        else:
            b = Button(text=_("Create unsigned transaction"), on_press=self.do_send)
        hbox.add_widget(b)

        b = Button(text=_("Clear"), on_press=self.do_clear)
        hbox.add_widget(b)

        vbox.add_widget(hbox)
        return vbox

        # TODO: shortcut Up Down

    def update_completions(self):
        l = []
        for addr, label in self.wallet.labels.items():
            if addr in self.wallet.addressbook:
                l.append(label + '  <' + addr + '>')

        self.run_hook('update_completions', l)
        self.completions.setStringList(l)

    def protected(func):
        return lambda s, *args: s.do_protect(func, args)

    def do_send(self, instance):
        password = None  # NOTE: always None from original code

        label = unicode(self.message_e.text)
        r = unicode(self.payto_e.text).strip()

        # label or alias, with address in brackets
        m = re.match('(.*?)\s*\<([1-9A-HJ-NP-Za-km-z]{26,})\>', r)
        to_address = m.group(2) if m else r

        if not is_valid(to_address):
            return self.error_box(content_text=_('Invalid Bitcoin Address') + ':\n' + to_address)

        try:
            amount = self.read_amount(unicode(self.amount_e.text))
        except:
            return self.error_box(content_text=_('Invalid Amount'))
        try:
            fee = self.read_amount(unicode(self.fee_e.text))
        except:
            return self.error_box(content_text=_('Invalid Fee'))

        try:
            tx = self.wallet.mktx([(to_address, amount)], password, fee, account=self.current_account)
        except BaseException, e:
            return self.info_box(content_text=str(e))

        if tx.requires_fee(self.wallet.verifier) and fee < MIN_RELAY_TX_FEE:
            return self.error_box(content_text=_('This transaction requires a higher fee, or it will not be propagated by the network.'))

        self.run_hook('send_tx', tx)

        if label:
            self.set_label(tx.hash(), label)

        if tx.is_complete:
            h = self.wallet.send_tx(tx)
            #### TODO: waiting_dialog(lambda: False if self.wallet.tx_event.isSet() else _("Please wait..."))
            status, msg = self.wallet.receive_tx(h)
            if status:
                self.error_box(content_text=_('Payment sent.') + '\n' + msg)
                self.do_clear()
                #### TODO: self.update_contacts_tab()
            else:
                self.error_box(content_text=msg)
        else:
            filename = label + '.txn' if label else 'unsigned_%s.txn' % (time.mktime(time.gmtime()))
            try:
                #### TODO: fileName = self.getSaveFileName(_("Select a transaction filename"), filename, "*.txn")
                with open(fileName, 'w') as f:
                    f.write(json.dumps(tx.as_dict(), indent=4) + '\n')
                #### TODO: QMessageBox.information(self, _('Unsigned transaction created'), _("Unsigned transaction was saved to file:") + " " + fileName, _('OK'))
            except:
                self.error_box(content_text=_('Could not write transaction to file'))

    def set_url(self, url):
        # TODO:
        pass

    def do_clear(self, instance):
        # self.payto_sig.setVisible(False)
        for e in [self.payto_e, self.message_e, self.amount_e, self.fee_e]:
            e.text = ''
            # self.set_frozen(e, False)
        # self.update_status()

    def set_frozen(self, entry, frozen):
        # NOTE: not sure the Kivy has equivalent feature
        pass

    def toggle_freeze(self, addr):
        # TODO
        pass

    def toggle_priority(self, addr):
        # TODO
        pass

    def do_protect(self, func, args):
        if self.wallet.use_encryption:
            password = self.password_dialog()
            if not password:
                return
        else:
            password = None

        if args != (False,):
            args = (self,) + args + (password,)
        else:
            args = (self, password)
        apply(func, args)

    def create_list_tab(self, headers):
        # NOTE: don't need this generic function in Kivy GUI
        pass

    # NEW
    def add_tab(self, widget, title):
        tab = TabbedPanelItem(text=title)
        tab.add_widget(widget)
        self.tabs.add_widget(tab)

    # NEW: extracted from self.__init__()
    def show(self):
        self.tabs = TabbedPanel(do_default_tab=False)
        self.add_tab(self.create_history_tab(), _('History'))
        self.add_tab(self.create_send_tab(), _('Send'))

        tab_receive = TabbedPanelItem(text=_('Receive'))
        tab_contacts = TabbedPanelItem(text=_('Contacts'))
        tab_console = TabbedPanelItem(text=_('Console'))
        self.tabs.add_widget(tab_receive)
        self.tabs.add_widget(tab_contacts)
        self.tabs.add_widget(tab_console)

        self.layout.add_widget(self.tabs, 2)

        title = 'Electrum ' + self.wallet.electrum_version + '  -  ' + self.conf.path
        if not self.wallet.seed: title += ' [%s]' % (_('seedless'))

        self.app.title = title  # TODO: why not update?

        # TODO: no need shortcut for Kivy

        # [(u'26f5c788384cd5bf4b324d1bc89d64dc74c2fb84de96376ce555e9951ad29d0e',
        #   2533,
        #   False,
        #   1000000,
        #   25599980000,
        #   1000000,
        #   1366219927),
        #  (u'a53001c733c7e2fd29daadcb3f2e3cb3a5d48721f139fdcd8a4f10f929a87c5d',
        #   855,
        #   False,
        #   111111110,
        #   711970423,
        #   112111110,
        #   1367129298)]

        # TODO: add shortcuts

    # NEW
    def create_status_bar(self):
        self.status_text = ""
        sb = StatusBar()

        # update_notification = UpdateLabel(self.config)
        # if(update_notification.new_version):
        #    sb.addPermanentWidget(update_notification)

        # accounts = self.wallet.get_accounts()
        # if len(accounts) > 1:
        #    from_combo = QComboBox()
        #    from_combo.addItems([_("All accounts")] + accounts.values())
        #    from_combo.setCurrentIndex(0)
        #    self.connect(from_combo, SIGNAL("activated(QString)"), self.change_account)
        #    sb.addPermanentWidget(from_combo)

        if self.wallet.seed:
            self.password_button = Button(text=_("Password"), on_press=self.change_password_dialog)
            sb.add_button(self.password_button)

        # self.password_pref = Button(text=_("Preferences"), on_press=self.settings_dialog)
        # sb.add_button(self.password_pref)
        if self.wallet.seed:
            self.seed_button = Button(text=_("Seed"), on_press=self.seed_dialog)
            sb.add_button(self.seed_button)
        # self.status_button = Button(text=_("Network"), on_press=self.run_network_dialog)
        # sb.add_button(self.status_button)

        self.run_hook('create_status_bar', (sb,))

        self.layout.add_widget(sb.layout, 1)

    def password_dialog(self, instance=None):
        """Can be called directly or from callback"""
        wallet = self.wallet

        dialog = Dialog(title=_('Password'))

        pw = TextInput(password=True)

        grid = GridLayout(cols=2)

        grid.add_widget(Label(text=_('Please enter password')))
        grid.add_widget(pw)

        dialog.add_content(grid)

        def on_cancel_click(instance):
            dialog.close()
            # self.load_wallet()

        def on_ok_click(instance):
            password = unicode(pw.text) if wallet.use_encryption else None

            try:
                seed = wallet.decode_seed(password)
            except:
                return self.error_box(content_text=_('Incorrect Password'))

            dialog.close()

            self.show_seed(seed, self.wallet.imported_keys, self)


        button_cancel = Button(text=_("Cancel"), on_press=on_cancel_click)
        button_ok = Button(text=_("OK"), on_press=on_ok_click)

        dialog.add_button(button_cancel)
        dialog.add_button(button_ok)

        dialog.open()

    @protected
    def seed_dialog(self, instance):
        if not self.wallet.seed:
            return self.error_box(content_text=_('No seed'))
        return self.show_seed(self.wallet.seed, self.wallet.imported_keys)


class ElectrumApp(App):
    title = _('Electrum App')

    def __init__(self, wallet, conf, *args, **kwargs):
        super(ElectrumApp, self).__init__(*args, **kwargs)
        self.wallet = wallet
        self.conf = conf  # conflicting name 'config'

    def build(self):
        return BoxLayout()

    def on_start(self):
        gui = ElectrumSetupGui(app=self)
        if not gui.conf.wallet_file_exists:
            gui.restore_or_create()
            # gui.show_seed('12345678', False)
            # gui.verify_seed()
            # gui.network_dialog(self.wallet, None)
            # gui.password_dialog()
        else:
            gui.load_wallet()


def arg_parser():
    usage = "usage: %prog [options] command\nCommands: " + (', '.join(known_commands))
    parser = optparse.OptionParser(prog=usage)
    parser.add_option("-g", "--gui", dest="gui", help="User interface: qt, lite, gtk or text")
    parser.add_option("-w", "--wallet", dest="wallet_path", help="wallet path (default: electrum.dat)")
    parser.add_option("-o", "--offline", action="store_true", dest="offline", default=False, help="remain offline")
    parser.add_option("-a", "--all", action="store_true", dest="show_all", default=False, help="show all addresses")
    parser.add_option("-b", "--balance", action="store_true", dest="show_balance", default=False, help="show the balance of listed addresses")
    parser.add_option("-l", "--labels", action="store_true", dest="show_labels", default=False, help="show the labels of listed addresses")
    parser.add_option("-f", "--fee", dest="tx_fee", default=None, help="set tx fee")
    parser.add_option("-F", "--fromaddr", dest="from_addr", default=None, help="set source address for payto/mktx. if it isn't in the wallet, it will ask for the private key unless supplied in the format public_key:private_key. It's not saved in the wallet.")
    parser.add_option("-c", "--changeaddr", dest="change_addr", default=None, help="set the change address for payto/mktx. default is a spare address, or the source address if it's not in the wallet")
    parser.add_option("-s", "--server", dest="server", default=None, help="set server host:port:protocol, where protocol is t or h")
    parser.add_option("-p", "--proxy", dest="proxy", default=None, help="set proxy [type:]host[:port], where type is socks4,socks5 or http")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False, help="show debugging information")
    parser.add_option("-P", "--portable", action="store_true", dest="portable", default=False, help="portable wallet")
    parser.add_option("-L", "--lang", dest="language", default=None, help="defaut language used in GUI")
    parser.add_option("-u", "--usb", dest="bitkey", action="store_true", help="Turn on support for hardware wallets (EXPERIMENTAL)")
    return parser


if __name__ == "__main__":
    parser = arg_parser()
    options, args = parser.parse_args()
    if options.portable and options.wallet_path is None:
        options.wallet_path = os.path.dirname(os.path.realpath(__file__)) + '/electrum.dat'
    set_verbosity(options.verbose)

    # config is an object passed to the various constructors (wallet, interface, gui)
    import __builtin__
    __builtin__.use_local_modules = True  # TODO: remove hard-coded

    is_android = False  # TODO: remove hard-coded
    if is_android:
        config_options = {'wallet_path':"/sdcard/electrum.dat", 'portable':True, 'verbose':True, 'gui':'android', 'auto_cycle':True}
    else:
        config_options = eval(str(options))
        for k, v in config_options.items():
            if v is None: config_options.pop(k)

    # Wallet migration on Electrum 1.7
    # Todo: In time we could remove this again
    if platform.system() == "Windows":
        util.check_windows_wallet_migration()

    el_conf = SimpleConfig(config_options)
    el_wallet = Wallet(el_conf)

    interface = Interface(el_conf, True)
    el_wallet.interface = interface

    app = ElectrumApp(el_wallet, el_conf)
    app.run()
